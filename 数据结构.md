# 常用函数

strip（）：表示移除开头或者结尾指定的字符，默认是空格或换行符

sys.version_info > (3, 0)：可以检测python的版本 

pickle.load（）：对数据流进行反序列化

numpy.sort（）：对数组元素或者是列表的类数组元素进行排序，列表排序之后返回的就不是列表数据类型了

sparse.lil_matrix（）：创建一个稀疏矩阵，而且可以从提取出特定的行和列

sparse.coo_matrix（）：和上一个一样，返回的也是稀疏矩阵

sparse.isspmatrix_coo（）：判断是否是coo_matrix类型的稀疏矩阵

sparse.eye（）：构建对角线为1的稀疏矩阵

sparse.diags（）：构建对角矩阵，可以含有偏移量

sp.vstack（）：表示按照垂直方向将数组堆叠起来，hstack,stack都有类似的意思，都是将数组堆叠起来

tolist（）：将。。。。转换成列表，可以是数组，也可以是矩阵

transport（）：不指定参数，默认就是转置，指定参数参考网上

instance（）：判断一个对象是否是一个已知类型，会参考继承关系，type就不会参考，所以判断两个对象的类型是否相同，推荐instance（）

map（函数名称，元素）：让后面的元素执行前面的函数，返回一个迭代器对象，可以使用list（）变成list
		这个函数名称可以是python自己定义的，也可以是def的
		如果在这使用无函数名的方式，可以用多参数，多种方法之间用：来分割

img.convert('')：PIL有九种不同模式: 1，L，P，RGB，RGBA，CMYK，YCbCr，I，F，这些都是填入''之中的
	1：为二值图像，非黑即白，每个像素用8个bit表示，0表示黑，255表示白
	L：为灰度图像，每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度
	L = R * 299/1000 + G * 587/1000+ B * 114/1000
	P：8位像素，使用调色板映射到其他模式。
	RGB：3x8位像素，为真彩色。
	RGBA：4x8位像素，有透明通道的真彩色。
	CMYK：4x8位像素，颜色分离。
	YCbCr：3x8位像素，彩色视频格式。
	I：32位整型像素。
	F：32位浮点型像素

np.reshape(需要改变格式的矩阵，（1，2）)
	（1，2）表示创建一个1行2列的二维数组
	（3，1，2）表示创建一个3个1X2的数组
	（2，3，1，2）表示创建一个四维数组

os.path.exists(文件路径)：判断文件是否存在这个目录下

os.path.split(文件路径)：分割出文件路径和文件名，保存至二元组中

os.path.splitext(文件路径)：分割出文件名和拓展名，保存至二元组，.跟在拓展名中

os.path.abspath(文件路径)：返回规范化的绝对路径

 

np.save(file, arr, allow_pickle=True, fix_imports=True)：将数组保存到一个文件路径中

file为文件路径，没有设置就是保存至默认路径中，文件拓展名为.npy，arr为需要保存的数组

np.savez(file, arr1, arr2)：将多个数组保存到同一个文件中

![  call（）：用于类中，将整个类变成一个函数，使这个类的实例可以像函数一样被调用 class A: def __init__(self, *args, **kwargs) def __call__(self, **kwargs)  ](data:image/png;base64,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)

sklearn.preprocessing.MinMaxScaler(feature_range=(0, 1), copy=True)
	feature_range：为元组类型，范围某认为:[0，1]，也可以取其他范围值。
	copy：为拷贝属性，默认为True,表示对原数据组拷贝操作，这样变换后元数组不变，False表 示变换操作后，原数组也跟随变化，相当于c++中的引用或指针。	可以单独使用：MinMaxScaler(feature_range=(0, 1))

StandardScale()：标准化数据，保证每个维度的特征数据的方差为1，均值为0，也就是数据归一化 

fit_transform()：先拟合数据，再进行标准化，先拟合数据表示找出其方差、标准差、最大值、最小值等固有的指标 

transform()：数据标准化

一般都是对训练集的数据使用fit_transform（），对测试集的数据使用transform（），一定要让数据在同一个标准下，也就是测试集的数据需要先拟合然后再标准化成一个标准的数据，后续测试集的数据就不能再更改标准了，所以就不需要拟合了

 

inverse_transform（）：将标准化后的数据转换成原始的数据

split（）：当里面什么都不放的时候，就是按照空格进行分割，返回的是一个列表



**random**
在两个数之间随机选择一个：

```python
import random
c = [1, 2]
print(random.random(c))   # 1或2
```

在一个区间内选择数（闭区间）：

```python
import random
random.randint(10, 20)   # 随机选取一个[10,20]之间的整数
random.random(10, 20)   # 随机选取一个[10,20]之间的数，可以是小数
```



# pandas

pandas以字典的方式提取列的值：df['A']，提取的就是A列的值
	提取行的数据：df.iloc[[2]]：表示提取的是index=2的行的值，也就是第3行的值
				   df.loc[[2]]：表示提取的是第2行的值
	一般而言，loc和iloc两个函数，一旦中间有‘，’分隔开的话，前面表示行，后面表示列，一个单独的‘：’表示全部行/列

```python
df.loc[df['b'][(df['b'] > 49)|(df['b'] < 10)].index, 'b'] = np.nan # 将b列中所有大于49或小于10的值赋值为null值
df.loc[(df['b'].isnull()), 'b'] = 0 # 再将b列中所有null值全部赋值为0
df.loc[(df['b'].notnull()), 'b'] = 0 # 或将b列中所有非null值全部赋值为0
df_a,df_c = df.loc[(df['b'] > 50)|(df['b'] < 10),('a','c')].values[2] # 根据b列中的值来选取a,c两列的值，并将返回结果中的第三行赋值到df_a和df_c中

df.iloc[0:2,[0,1]] # 选取df前两行的第一和第二列，行序号为2的第三行不包括在内
df.iloc[:,0:3] # 选取df的前三列，行序号为3的第四行不包括在内
选取时是前闭后开

df.iloc[0:2,[0,1]] # 返回对象类型为DataFrame
df.iloc[1,0:2] # 返回对象为Series
df.loc[0:1,['b','c']] # 返回对象为DataFrame
df.loc[1,'a':'c'] # 返回对象为Series
df.loc[:,['b','c']] # 返回对象为DataFrame
# 如果两个参数都是列表，则返回DataFrame，如果不是就返回Series
```

# 简单的代码

## 匹配一句话

```python
import random

word = 'to be or not to be'
num = len(word)


def create(number):
    sb_list = []
    while len(sb_list) < number:
        # a_str = string.ascii_letters
        # a_str 这个是直接使用string类中的变量
        b_str = 'abcdefghijklmnopqrstuvwxyz '
        random_letters = random.choice(b_str)
        sb_list.append(random_letters)
    return ''.join(sb_list)
    # 这个方法是将列表中的元素转成字符串并且拼接起来


def match(letters):
    words = create(num)
    list_ad = []
    count = 0
    for i in range(0, len(words)):
        for j in range(0, len(letters)):
            while words[i] != letters[i]:
                words = create(num)
            count += 1
        # 不放在j循环里面，是防止重复出现第i位的元素
        list_ad.append(words[i])
    print(''.join(list_ad))
    print(count)


match(word)
```

## "变为词"判断

```python
import random


data = [10, 2, 6, 3]


def sort1():
    for i in range(0, len(data)):
        for j in range(0, i):
            if data[j] < data[j+1]:
                temp = data[j]
                data[j] = data[j+1]
                data[j+1] = temp
    print(data[0])


def sort2():
    j = 0
    while j < len(data)-1:
        if data[j] < data[j + 1]:
            temp = data[j]
            data[j] = data[j + 1]
            data[j + 1] = temp
        j += 1
    else:
        print(data)


string1 = "python"


def create(number):
    sb_list = []
    while len(sb_list) < number:
        b_str = 'abcdefghijklmnopqrstuvwxyz'
        random_letters = random.choice(b_str)
        sb_list.append(random_letters)
    return sb_list


def anagram_solution1(s1, s2):
    a_list = list(s2)
    pos1 = 0
    still_ok = True
    # 表示只有两者都是True才会返回true，此时才会执行while的代码
    while pos1 < len(s1) and still_ok:
        if a_list[pos1] in s1:
            pos1 += 1
        else:
            still_ok = False
    if still_ok is False:
        print("no")
    else:
        print("yes")


anagram_solution1("abcd","dbca")
```

## 判断括号是否匹配对位

```python
class Match(object):
    stack = []  # 建立一个空的栈

    def size(self):
        return len(self.stack)

    def pop(self):
        return self.stack.pop()

    def check(self, list1):
        o = '([{'
        c = ')]}'
        while len(list1) != 0:
            if list1[0] in '([{':
                self.stack.append(list1[0])
                del list1[0]
            if list1[0] in ')]}':
                if self.size() == 0:
                    # 如果多一个，那么此时的self.size() == 0，那么避免bug就可以退出循环，因为此时len(list1) != 0
                    break
                else:
                    # stack中还存在，代表还可以匹配，所以就从top移除它，并减少list存放
                    opens = self.stack.pop()
                    closes = list1[0]
                    if o.index(opens) != c.index(closes):
                        # 确保要删除的两项在这两个列表中的索引位置是相同的，因为这两个列表中的值是一一对应的
                        # 索引值不同，就代表肯定不是一对括号，所以就跳出循环，匹配失败
                        break
                    del list1[0]
        if self.size() == 0 and len(list1) == 0:
            print('匹配成功')
        else:
            print('匹配失败')


k = '()([})'
list2 = list(k)   # 将括号放在列表中，便于取出和删除
print(list2)
a = Match()
a.check(list2)
```

## 传土豆问题

```python
'''
创建一个队列
'''
class Queue():
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        # 将List集合的首端作为队列的末端
        self.items.insert(0, item)

    def dequeue(self):
        # 将List集合的末端作为队列的首端
        return self.items.pop()

    def isEmpty(self):
        # 空集合返回True
        return self.items == []

    def size(self):
        return len(self.items)


def potato(name_list, num):
    queue = Queue()
    for n in name_list:
        queue.enqueue(n)
    while queue.size() > 1:
        # 一个for循环就是一次传递，传递了num次，假设从首端开始传递
        for n in range(num):
            queue.enqueue(queue.dequeue())
        # 传递完成，此时在首端的人就出局
        queue.dequeue()
    # 当人数只有一个时，把该人的名字返回出去
    return queue.dequeue()


name = ['Bell', 'Brad', 'Kent', 'Jane', 'Susan', 'David', 'Rose']
print(potato(name, len(name)))
```

## 打印任务

```python
import random


class Queue():
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        # 将List集合的首端作为队列的末端
        self.items.insert(0, item)

    def dequeue(self):
        # 将List集合的末端作为队列的首端
        return self.items.pop()

    def isEmpty(self):
        # 空集合返回True
        return self.items == []

    def size(self):
        return len(self.items)


name = ['Bell', 'Brad', 'Kent', 'Jane', 'Susan', 'David', 'Rose', 'Meg', 'Miz', 'Ken']


# 首先全使用草稿模式来进行打印，每分钟10页
# 在这一小时内有10个人要打印
def print_c(name_list, time):
    q = Queue()
    for i in name_list:
        q.enqueue(i)
    # 总共循环两次，表示每个人都打印两次
    print('----------first---------')
    for n in range(len(name_list)):
        print_num = random.randint(10, 20)
        time = time + 6 * print_num
        q.enqueue(q.dequeue())
    print(time/60)
    print('----------second--------')
    for n in range(len(name_list)):
        print_num = random.randint(10, 20)
        time = time + 6 * print_num
        q.enqueue(q.dequeue())
    print(time/60)


# 使用正常模式打印，质量好，每分钟5页
def print_n(name_list, time):
    q = Queue()
    for i in name_list:
        q.enqueue(i)
    # 总共循环两次，表示每个人都打印两次
    print('----------first---------')
    for n in range(len(name_list)):
        print_num = random.randint(10, 20)
        time = time + 12 * print_num
        q.enqueue(q.dequeue())
    print(time / 60)
    print('----------second--------')
    for n in range(len(name_list)):
        print_num = random.randint(10, 20)
        time = time + 12 * print_num
        q.enqueue(q.dequeue())
    print(time / 60)


# 混合使用
def print_l(name_list, time):
    # 统计两种模式出现的次数
    num_6 = 0
    num_12 = 0
    q = Queue()
    for i in name_list:
        q.enqueue(i)
    # 表示在6和12之间选一个
    x = [6, 12]

    # 第一轮就算全部都选用正常模式也不会超过一小时，所以默认全部选取正常模式
    for n in range(len(name_list)):
        print_num = random.randint(10, 20)
        time = time + 12 * print_num
        q.enqueue(q.dequeue())

    for n in range(len(name_list)):
        print_num = random.randint(10, 20)
        times = random.choice(x)
        time = time + times * print_num
        if times == 6:
            num_6 += 1
        else:
            num_12 += 1
        q.enqueue(q.dequeue())
    return time, num_6, num_12


i = 0
results = {}
key = []
while i < 10:
    result = print_l(name, 0)
    if result[0] <= 3600 and result[2] >= result[1]:
        results[result[0]] = result[2]
        i += 1
    else:
        i += 1
key = results.keys()
max_result = max(key)
print(max_result)
print(results[max_result])
```

## 回问词判定

```python
class Deque:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def addFront(self, item):
        self.items.append(item)

    def addRear(self, item):
        self.items.insert(0, item)

    def removeFront(self):
        return self.items.pop()

    def removeRear(self):
        return self.items.pop(0)

    def size(self):
        return len(self.items)


def ban(str_train):
    d1 = Deque()
    d2 = Deque()
    for i in str_train:
        d1.addRear(i)
        d2.addFront(i)
    match = True
    for i in range(len(str_train) - 1):
        if d1.removeRear() == d2.removeRear():
            match = True
        else:
            print('error')
            match = False
            break
    return match


str_test = '上海自来水来自海上'
list_str = list(str_test)
print(ban(str_test))
```

## 零钱兑换问题

```python
def match_con(money):
    n_25 = money//25
    if n_25 > 0:
        n_10 = (money%25)//10
        if n_10 > 0:
            n_5 = ((money%25)%10)//5
        else:
            n_10 = 0
            n_5 = (money%25)//5
    else:
        n_25 = 0
        n_10 = money//10
        if n_10 > 0:
            n_5 = (money%10)//5
        else:
            n_10 = 0
            n_5 = money//5
    return n_25, n_10, n_5


def rec(cointValueList, change, know):
    # 使用记忆法来记录最优解，然后从表中找出最优的
    minCoins = change
    if change in cointValueList:
        know[change] = 1
        return 1
    elif know[change] > 0:
        return know[change]
    else:
        for i in [c for c in cointValueList if c <= change]:
            numCoins = 1 + rec(cointValueList, change-i, know)
            if numCoins < minCoins:
                minCoins = numCoins
                # 此时是最优解，记录到表中
                know[change] = minCoins
    return minCoins


def matchT(listm, money, minCoins):
    # 这是的动态规划
    for cents in range(1, money + 1):
        # 初始化一个最大的值
        coinCount = cents
        # 减去每一个硬币，向后查找最少硬币数，同时记录最少的个数
        for j in [c for c in listm if c <=cents]:
            if minCoins[cents-j] + 1 < coinCount:
                coinCount = minCoins[cents-j] + 1
            minCoins[cents] = coinCount
    return minCoins[money]


def matchM(listm, money, minCoins, coinUsed):
    # 这是最优的动态规划
    for cents in range(1, money + 1):
        # 初始化一个最大的值
        coinCount = cents
        newCoin = 1  # 初始化新加入的硬币
        # 减去每一个硬币，向后查找最少硬币数，同时记录最少的个数
        for j in [c for c in listm if c <= cents]:
            if minCoins[cents - j] + 1 < coinCount:
                coinCount = minCoins[cents - j] + 1
                newCoin = j  # 对应最小数量，需要减的硬币
            minCoins[cents] = coinCount
            coinUsed[cents] = newCoin
    return minCoins[money]


def printCoint(coinsUsed, money):
    coin = money
    while coin > 0:
        thisCoin = coinsUsed[coin]
        print(thisCoin)
        coin = coin - thisCoin


amnt = 63
clist = [1, 5, 10, 21, 25]
coinUsed = [0]*(amnt+1)
coinCount = [0]*(amnt+1)

print(matchM(clist, amnt, coinCount, coinUsed))
printCoint(coinUsed, amnt)
```

## 宝物最大值问题

```python
tr = [None, {'w': 2, 'v': 3}, {'w': 3, 'v': 4}, {'w': 4, 'v': 8}, {'w': 5, 'v': 8}, {'w': 9, 'v': 10}]
max_w = 20
# 初始化一个二维表格，i[0,5]，w[0,20]，这是i和w的范围，w是指总重，表示前i个宝物中w的重量
m = {(i, w): 0 for i in range(len(tr))
                 for w in range(max_w+1)}

for i in range(1, len(tr)):
    # 一直在第i行，直至w=21
    for w in range(1, max_w+1):
        if tr[i]['w'] > w:  # 装不下第i个宝物，表示第i个宝物的重量要大于总重量
            m[(i, w)] = m[(i-1, w)]   # 不装第i个宝物，修改字典中key所对应的value值
        else:
            # 选取两种结果的最大值
            m[(i, w)] = max(
                m[(i-1, w)],
                m[(i-1, w-tr[i]['w'])]+tr[i]['v']  # 表示在加上第i个宝物的时候，前i-1个宝物在当时的重量下的最大值
            )
# print(m)
# 输出结果，最大的价值，也就是(5,20)所对应的value是多少，也就是最后一位
print(m[(len(tr)-1, max_w)])


# 使用递归的思想更加的自然
trs = {(2,3), (3,4), (4,8), (5,8), (9,10)}
s = {}
def thief(trs, w):
    if trs == set() or w == 0:
        s[(tuple(trs), w)] = 0
        return 0
    elif (tuple(trs), w) in m:
        return s[(tuple(tr), w)]
    else:
        vmax = 0
        for t in trs:
            if t[0] <= w:
                v = thief(trs-{t}, w-t[0]) + t[1]
                vmax = max(vmax, v)
        s[(tuple(trs), w)] = vmax
        return vmax

print(thief(trs,20))
```



# 基本数据结构

以下的四种大致上是一样的，只是数据项之间存在着先后的次序，但是都是线性结构

## 栈（stack）

**有次序**的数据项**集合**，数据项的加入或者移除都只会发生在同一端（顶top，底base）
距离**base**越近的，留在数据集合中最久，首先移除的是top
**后进先出**，在**java**中栈内存就是这么存放数据的，所以在栈中存放时间越久，那么离base越近，存放时间越短，离top越近

进栈和出栈的顺序是反过来的：在浏览器中的**后退**也是如此

### ==代码操作==

```python
Stack()   # 创建一个空栈，不包含任何的数据项
push(item)    # 将itrm加入栈顶，无返回值
pop()   # 将栈顶数据移除，并返回，栈被修改
peek()  # 返回栈顶的数据项，对栈不进行操作
isEmpty()   # 返回栈是否是空栈
size()   # 返回栈中数据项的数目


s = Stack()       # []  空的栈
s.isEmpty()         # True
s.push(4)        # [4]
s.push('dog')       # [4, 'dog']
s.peek()         # 'dog'
s.push(True)     # [4, 'dog', True]
s.size()     # 3
s.pop()       # [4, 'dog']
s.size()        # 2
```

### **python 实现**

将Stack做成python中的一个**Class**，然后将其操作做成class中的**方法**，stack是一个数据集，所以可以采用python的原生数据集（list，dict）

可以选用List数据集，将**index=0**一端作为**base**，将**index=-1**一段作为**top**，这样List的**append，pop**就可以实现栈顶输入输出的功能

```python
class Stack():
    def __init(self):
        self.items = []
    def isEmpty(self):
		return self.items == []
    def push(self, item):
		self.items.append(item)
    def pop(self):
        return self.items.pop()
    def peek(self)
    	return self.items[len(self.items.size() - 1)]
    def size(self):
        return len(self.items)
```

```python
# 在列表中插入某一项，这个可以作为index=0作为top的class来用
def push(self, item):
    self.items.insert(0, item)
def pop(self):
	return self.items.pop(0)
```

## 队列（Queue）

**有次序**的数据**集合**，新数据项的添加总是发生在一端（通常在**尾端rear**），现存数据项的移除通常在**首端front**

==*==  当数据项加入队列时，首先出现在队尾，随着队首数据项的移除，再逐渐靠近队首，**先进先出**

==打印队列==、==进程调度==、==键盘缓冲==

```python
Queue()   # 创建一个空的队列对象，返回值是Queue对象
enqueue(item)   # 将数据项item添加至队尾，无返回值
dequeue()   # 从队首移除数据项，返回值为队首数据项，队列被修改
isEmpty()   # 判断是否是空队列，返回值是Boolean
size()      # 返回队列中数据项的个数

class Queue():
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        # 将List集合的首端作为队列的末端
        self.items.insert(0, item)
        # self.items.append(item)

    def dequeue(self):
        # 将List集合的末端作为队列的首端
        return self.items.pop()
        # return self.items.pop(0)

    def isEmpty(self):
        # 空集合返回True
        return self.items == []

    def size(self):
        return len(self.items)
```

## 双端队列（Deque）

和队列相似，数据项可以从两端加入或移除，集成了栈和队列的功能，但是并不存在**先入先出**或**先进后出**的功能

```python
'''
index=0的作为deque的尾端
index=-1的作为deque的首端
'''
class Deque:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def addFront(self, item):
        self.items.append(item)

    def addRear(self, item):
        self.items.insert(0, item)

    def removeFront(self):
        return self.items.pop()

    def removeRear(self):
        return self.items.pop(0)

    def size(self):
        return len(self.items)
```



## 列表（List）

### 无序表

数据项按照**相对位置存放**的数据集，仅仅只是按照存放位置来索引，也就是index（下标）

```python
List()   # 创建一个空的列表
add(item)   # 添加一个数据项到列表之中
remove(item)   # 移除一个列表中的数据项
search(item)   # 在列表中查找item，返回Boolean
isEmpty()   # 返回列表是否为空
size()   # 返回列表包含多少个数据项
append(item)   # 将一个数据项添加到末尾
index(item)   # 返回数据项在表中的位置，也就是返回其下标索引
insert(pos, item)   # 将数据项插在index = pos处，且item原先不存在该列表中
pop()    # 从列表的末尾移除数据项item
pop(pos)  # 移除index = pos的数据项，并且移除之后整个列表要往前移动

'''
采用链表的方式来存放列表
使用单链表的方式，那么按照链表的定义，需要有节点的实现
节点需要有自身的信息，也需要有下一个节点的信息，所以需要get 和set 方法来获取当前节点和下一个节点的信息
'''
class Node:
    # 创建节点类，用于定义链表中的节点
    def __init__(self, nodedata):
        self.node = nodedata
        self.next = None

    def getNode(self):
        return self.node

    def getNext(self):
        return self.next

    def setNode(self, newNode):
        self.node = newNode

    def setNext(self, newNext):
        self.next = newNext


class Create_list:
    def __init__(self):
        self.head = None

    def add(self, item):
        # 将传入的数据做成一个节点，将这个节点放在头节点，然后将头节点的下一个节点变成新的头节点
        # 这样就可以一直的在头节点处添加新的节点，对于新加入的数据每一个加入的位置都是头节点的位置
        # 链表结构如果想访问所有的数据项，就必须从head节点开始，所以最快添加数据的位置就是头列表
        temp = Node(item)
        temp.setNext(self.head)
        self.head = temp

    def remove(self, item):
        current_node = self.head
        last_node = None
        find = False
        while not find:
            if current_node.getNode() == item:
                find = True
            else:
                last_node = current_node
                current_node = current_node.getNext()
        if last_node == None:
            self.head = current_node.getNext()
        else:
            last_node.setNext(current_node.getNext())

    def search(self, item):
        current_node = self.head
        last_node = None
        find = False
        # 一旦current_node == None，表示这是一个空链表，那么就会报错，因为Node不会有任何方法
        while not find and current_node != None:
            if current_node.getNode() == item:
                find = True
            else:
                last_node = current_node
                if current_node.getNext() == None:
                    find = False
                    break
                else:
                    current_node = current_node.getNext()
        return find

    def isEmpty(self):
        return self.head == None

    def size(self):
        current_node = self.head
        count = 1
        # 直到current_node.getNext() == None才结束，此时的current_node != None，所以初始count=1
        while current_node != None:
            if current_node.getNext() != None:
                count += 1
                current_node = current_node.getNext()
            else:
                break
        return count
```

### 有序表

按照一定的顺序排列的链表

**最后可以加一个打印的代码**

```python
# 唯一的难点就在于当数据项加入整个链表之后，必须保持这个链表的排序
class Node:
    # 创建节点类，用于定义链表中的节点
    def __init__(self, nodedata):
        self.node = nodedata
        self.next = None

    def getNode(self):
        return self.node

    def getNext(self):
        return self.next

    def setNode(self, newNode):
        self.node = newNode

    def setNext(self, newNext):
        self.next = newNext


class OrderList():
    def __init__(self):
        self.head = None

    def add(self, item):
        current = self.head
        last = None
        stop = False
        # 发现插入的位置
        while current != None and not stop:
            if current.getNode() > item:
                stop = True
            else:
                last = current
                current = current.getNext()
        temp = Node(item)
        # 插入表头
        if last == None:
            temp.setNext(self.head)
            self.head = temp
        # 插入末尾
        else:
            temp.setNext(current)
            last.setNext(temp)

    def search(self, item):
        # 利用有序的特点，可以更快地找到是否存在该数值
        current = self.head
        find = False
        stop = False
        while current != None and not find and not stop:
            if current.getNode() == item:
                find = True
            else:
                if current.getNode() > item:
                    stop = True
                else:
                    current = current.getNext()
        return find
    
	# 将这个链表打印出来的代码
    def print_data(self):
        a = []
        current = self.head
        while current != None:
            if current != None:
                a.append(current.getNode())
                current = current.getNext()
            else:
                break
        return a
```

# 递归

## 简介

在算法流程之中**调用自身**

```python
# 使用递归实现列表中元素的相加
def sums(list1):
    if len(list1) == 1:
        return list1[0]
    else:
        return list1[0] + sums(list1[1:])
# 使用递归实现二进制到十六进制之间的任意转换
def toStr(n, base):
    convertString = '0123456789ABCDEF'
    if n < base:
        return convertString[n]
    else:
        return toStr(n // base, base) + convertString[n%base]
    # // 表示返回除法的整数（向下取整）
    # % 表示返回除法的余数
```

**递归调用在栈中实现很多**

每一次调用，压入栈的**现场数据**称为**栈帧**，当函数返回时，要从调用栈的**栈顶**取得**返回地址**，恢复现场，**弹出栈帧**，按照地址返回

## **递归可视化：**

### 分形树

**python的海龟作图系统（turtle model）**
	内置，以LOGO语言的创意为基础
	模拟海龟在砂糖上爬行而留下足迹

```python
forward(n)   backward(n)  # 爬行   n——行走的距离
left(a)   right(a)   # 转向    a——转向的角度
penup()   pendown()   # 抬笔  放笔
pensize(s)    pencolor(c)   # 笔属性

import turtle
t = turtle.Turtle()
# 作图开始
t.forward(100)  # 指挥海龟作图，此时画出来的就是一个直线
# 画一个正方形
for i in range(4):
    t.forward(100)
    t.right(90)
# 画一个五角星
t.pensize(3)
t.pencolor('red')
for i in range(5):
    t.forward(100)
    t.right(144)
t.hideturtle()
# 作图结束
turtle.done()
```

使用递归来画图（螺旋）：

```python
import turtle
t = turtle.Turtle()
# 作图开始
t.pensize(3)
t.pencolor('red')
def drawS(t, linelen):
    if linelen > 0:
        t.forward(linelen)
        t.right(90)
        drawS(t, linelen - 5)
drawS(t, 100)
# 作图结束
turtle.done()
```

因为自然界中的物体很多都是具有自相似的，也就是说放大了看都是由很多很相似的物体组成的

所以就可以使用**递归**来做出**自相似图形** ——**分形树**

```python
import turtle
t = turtle.Turtle()
# 作图开始
# 摆正笔的方向以及初始位置
t.left(90)
# t.penup()
# t.backward(100)
# t.pendown()
t.pensize(3)
t.pencolor('green')
def drawS(t, linelen):
    if linelen > 5:
        t.forward(linelen)
        t.right(20)
        drawS(t, linelen - 15)
        t.left(40)
        drawS(t, linelen - 15)
        t.right(20)
        t.backward(linelen)  # 回到原位置
drawS(t, 75)
# t.hideturtle()  # 画完结束之后隐藏turtle，也就是退出
# 作图结束
turtle.done()
```

### 谢尔宾斯基三角

将一个三角形中间按照三角形挖空，然后再在其余地方继续挖三角形

```python
import turtle


t = turtle.Turtle()


def triples(degree, points):
    color_tri = ['blue', 'red', 'green', 'white', 'yellow', 'orange']
    drawTriangle(points, color_tri[degree])
    # 最小规模，0直接退出
    if degree > 0:
        # 调用自身，左上右顺序，getMid表示边长减半，取geiMid参数两个点中间的点作为新的顶点
        triples(degree - 1, {'left':points['left'],
                             'top':getMid(points['left'], points['top']),
                             'right':getMid(points['left'], points['right'])})
        triples(degree - 1, {'left': getMid(points['left'], points['top']),
                             'top': points['top'],
                             'right': getMid(points['top'], points['right'])})
        triples(degree - 1, {'left': getMid(points['left'], points['right']),
                             'top': getMid(points['top'], points['right']),
                             'right': points['right']})


def drawTriangle(points, color):
    t.fillcolor(color)
    t.penup()
    t.goto(points['top'])
    t.pendown()
    t.begin_fill()
    t.goto(points['left'])
    t.goto(points['right'])
    t.goto(points['top'])
    t.end_fill()


def getMid(point1, point2):
    return ((point1[0] + point2[0])/2, (point1[1] + point2[1])/2)


points = {'left':(-200, -100),
          'top':(0, 200),
          'right':(200, -100)}
triples(5, points)
turtle.done()
```

### 汉诺塔问题

移动圆盘改变位置，总共需要$2^{64}-1$次移动

```python
def moveTower(hight, fromPole, withPole, toPole):
    if hight >= 1:
        moveTower(hight - 1, fromPole, toPole, withPole)
        # 因为上一个递归的代码在hight = 0的时候结束了，所以就会接着执行下一个语句
        # 在执行这个语句的时候，hight并没有执行hight - 1的操作，所以此时的hight = 1
        moveDisk(hight, fromPole, toPole)
        moveTower(hight - 1, withPole, fromPole, toPole)

def moveDisk(disk, fromPole, toPole):
    print(f'Moving disk[{disk}] from {fromPole} to {toPole}')


moveTower(3, '#1', '#2', '#3')
```

### 海龟迷宫问题

![image-20201223144623414](C:\Users\梅桂楠\AppData\Roaming\Typora\typora-user-images\image-20201223144623414.png)

需要有一个机制来就海龟走过的路径

![image-20201223144848640](C:\Users\梅桂楠\AppData\Roaming\Typora\typora-user-images\image-20201223144848640.png)

![image-20201223144910674](C:\Users\梅桂楠\AppData\Roaming\Typora\typora-user-images\image-20201223144910674.png)

```python
class Maze:
    def __init__(self, mazeFileName):
        rowsInMaze = 0
        columsInMaze = 0
        self.mazelist = []
        mazeFile = open(mazeFileName, 'r')
        rowsInMaze = 0
        for line in mazeFile:
            rowlist = []
            col = 0
            for ch in line[:-1]:
                rowlist.append(ch)
                if ch =='S':
                    self.startRow = rowsInMaze
                    self.startcol = col
                col += 1
            rowsInMaze += 1
            self.mazelist.append(rowlist)
            columsInMaze = len(rowlist)

    def udatePosition(self, startRow, startColum):

    def isExit(self, startRow, startColum):


def searchFrom(maze, startRow, startColum):
    # 碰到墙壁，返回失败
    maze.udatePosition(startRow, startColum)
    if maze[startRow][startColum] == OBSTACLE:
        return False
    # 碰到面包屑或者是死胡同，返回失败
    if maze[startRow][startColum] == TRIEN or maze[startRow][startColum] == DEAD_END:
        return False
    # 碰到出口，成功
    if maze.isExit(startRow, startColum):
        maze.udatePosition(startRow, startColum, PART_OF_PATH)
        return True
    # 洒下面包屑，继续探索
    maze.udatePosition(startRow, startColum, TRIED)
    # 向东南西北四个方向继续探索
    found = searchFrom(maze, startRow-1, startColum) or \
            searchFrom(maze, startRow+1, startColum) or \
            searchFrom(maze, startRow, startColum-1) or \
            searchFrom(maze, startRow, startColum+1)
    # 如果探索成功，标记当前点，失败则标记为死胡同
    if found:
        maze.udatePosition(startRow, startColum, PART_OF_PATH)
    else:
        maze.udatePosition(startRow, startColum, DEAD_END)
    return found
```

# 动态规划

从最简单的问题开始找到所需，每一步都是依靠以前的最优解来得到目前来说最优的解，直到知道答案
	在生成最优解列表的时候，同时跟踪记录最优解

```python
def matchM(listm, money, minCoins, coinUsed):
    # 这是最优的动态规划
    for cents in range(1, money + 1):
        # 初始化一个最大的值
        coinCount = cents
        newCoin = 1  # 初始化新加入的硬币
        # 减去每一个硬币，向后查找最少硬币数，同时记录最少的个数
        for j in [c for c in listm if c <= cents]:
            if minCoins[cents - j] + 1 < coinCount:
                coinCount = minCoins[cents - j] + 1
                newCoin = j  # 对应最小数量，需要减的硬币
            minCoins[cents] = coinCount
            coinUsed[cents] = newCoin
    return minCoins[money]


def printCoint(coinsUsed, money):
    coin = money
    while coin > 0:
        thisCoin = coinsUsed[coin]
        print(thisCoin)
        coin = coin - thisCoin


amnt = 63
clist = [1, 5, 10, 21, 25]
coinUsed = [0]*(amnt+1)
coinCount = [0]*(amnt+1)

print(matchM(clist, amnt, coinCount, coinUsed))
printCoint(coinUsed, amnt)
```



# 查找算法

- **顺序查找**

  可以按照index来有顺序的访问和查找数据项，这是针对于无序表的

- **二分法查找**

  列表中的数据项是有序的

- **冒泡排序**

```python
# 给冒泡排序增加了一个监测，检测是否进行过排序，如果进行过就不需要进行这一次的排序了，直接跳过
def shortCount(data):
    exchange = True
    passnum = len(data) - 1
    while passnum > 0 and exchange:
        exchange = False
        for i in range(passnum):
            if data[i] > data[i+1]:
                exchange = True
                item = data[i]
                data[i] = data[i+1]
                data[i+1] = item


data = [2,6,8,1]
shortCount(data)
```

- **插序排序**

```python
def text(data):
    for current_index in range(1, len(data)):
        current_value = data[current_index]
        index = current_index
        while index > 0 and data[index-1] > current_value:
            data[index] = data[index - 1]
            index = index - 1
        data[index] = current_value
    return data


data = [1,5,8,2]
print(text(data))
```

- **谢尔排序**

  在列表中划分出子列表，然后对子列表进行排序，重复进行，最终就是几个数字的插序排序

  ```python
  def text(data, start, gap):
      for current_index in range(start+gap, len(data), gap):
          current_value = data[current_index]
          index = current_index
          while index >= start and data[index-gap] > current_value:
              data[index] = data[index - gap]
              index = index - gap
          data[index] = current_value
      return data
  
  
  def sub_text(data):
      sub_index = len(data)//2
      while sub_index > 0:
          for index in range(sub_index):
              text(data, index, sub_index)
          sub_index = sub_index//2
      return data
  
  
  data = [1,5,8,2,7,9,10,12,3]
  print(sub_text(data))
  ```

- **归并排序**

  ```python
  def count(data):
      if len(data) <= 1:
          return data
      mid = len(data)//2
      left = count(data[:mid])
      right = count(data[mid:])
  
      i = j = k = 0
      while i < len(left) and j < len(right):
          if left[i] < right[j]:
              data[k] = left[i]
              i = i+1
              k = k+1
          else:
              data[k] = right[j]
              j = j+1
              k = k+1
      # 如果之前选取的是右边，就是说右边是最小值，那么此时就应该把左边的值放在index=1的位置，因为大
      while i < len(left):
          data[k] = left[i]
          i = i + 1
          k = k + 1
      # 此时之前选取的是左边，所以右边的值大，应该放在index=1的位置上
      while j < len(right):
          data[k] = right[j]
          j = j + 1
          k = k + 1
      return data
  
  
  def merge(data):
      if len(data) <= 1:
          return data
      mid = len(data)//2
      left = merge(data[:mid])
      right = merge(data[mid:])
  
      merged = []
      while left and right:
          if left[0] <= right[0]:
              merged.append(left.pop(0))
          else:
              merged.append(right.pop(0))
      merged.extend(right if right else left)
      return merged
  
  
  data = [1,5,8,2,7,9,10,12,3,11]
  print(merge(data))
  print(count(data))
  ```

- **快速排序**

  依据一个中值将数据表分为两半，然后使用递归

  设置左右标，中值

  ​	左标一直向右移动，碰到比中值大的就停止移动

  ​	右标一直向左移动，碰到比中值小的就停止移动

  ​	然后将左右标的数据项进行交换

  然后继续移动，直至左右标错开了停止移动，此时右标的位置就是新的中值的位置

  那么此时，新中值的左边都是比中值小的数据项，右边都是比中值大的数据项

```python
def sorts(data):
    sort2(data, 0, len(data)-1)
    return data


def sort2(data, first, last):
    if first < last:
        right = quic(data, first, last)
        sort2(data, first, right-1)
        sort2(data, right+1, last)


def quic(data, first, last):
    mid = data[first]
    left = first + 1
    right = last
    done = False
    while not done:
        while left <= right and data[left] <= mid:
            left = left + 1
        while left <= right and data[right] >= mid:
            right = right - 1
        if left > right:
            done = True
        else:
            data[left], data[right] = data[right], data[left]
    data[first], data[right] = data[right], data[first]
    return right


data = [1,5,8,2,7,9,10,12,3,11]
print(sorts(data))
```

# **散列表**

- 散列表：**哈希表**，其数据项的存储方式有利于快速查找定位

- 其中的每一个存储位置，都称为一个**”slot“**，每一个**槽**都有一个唯一的名称

  常用的散列方法：**求余数**，将数据项除以散列表的大小，得到的余数就作为槽号

  如果余数相同，也就是槽号相同，此时为**冲突collision**

- 最近似完美的函数就是：**MD5**和**SHA**

- MD5：将任何长度的数据都变换为固定为128位（16字节）的”摘要“，也就是129位的二进制

- python自带这些散列函数的库：**hashlib**

  ```python
  import hashlib
  hashlib.md5("hello world!").hexdigest()
  ```

- 可以使用**udate**来对任意长的数据分部分来计算

  ```python
  import hashlib
  
  
  m = hashlib.md5()
  # m.upadate 必须对要进行hash的数据项进行编码，如果是中文，就必须要对应中文的编码
  m.update('hello world!'.encode())
  m.update('this is part1'.encode())
  m.update('this is part2'.encode())
  print(m.hexdigest())
  ```

- **应用领域：**

  - 数据文件的一致性判断，判断文件是否内容相同
  - 网络文件下载的完整性
  - 网盘中相同的文件判断
  - 加密形式保存密码
  - 防止文件被篡改
  - 彩票投注应用
  - **区块链技术**

## 区块链

通过网络连接的节点，每一个节点都保存整个数据库中的数据

任何地方存入的数据都是得到同步

”去中心化“：不存在控制中心，每一个节点都是平等的，无法被控制

区块链由**区块（block）**组成，区块分成**头（head）**和**体（body）**

head：记录了一些元数据和链接到前一个区块的信息：生成时间，前一个区块（head+body）的散列值

body：记录了实际的数据

任何一个区块的数据发生了变化，就必然引起散列值的剧烈变化，为了不让这个区块脱离整个区块链，就要修改后续的所有的区块，此时就具有**”工作量证明“**

### 工作量证明

区块链是大规模的**分布式数据库**，新区块的添加速度需要得到控制，目前最大的是10分钟生成一个区块

有效散列值难以算出：

- 每一个区块都设置了一个难度系数（Difficulty），用常数（targetmax）来除以它，得到一个target，难度系数越高，target越小
- 必须找到一个数值Nonce，把它和整个区块数据一起计算散列值，且必须小于target才算是有效散列值
- 散列值无法回推原值，所以Nonce只能暴力穷举

## 散列函数的设计

**折叠法：**

- 将数据项按照位数分为若干段
- 再将几段数字相加
- 最后对散列表大小求余，得到散列值
- 有时候还会存在**隔数反转**步骤，比如**56**变成**65**

**平方取中法：**

- 将数据项做平方运算
- 取平方数中间两位
- 对散列表大小求余，利用这个中间的数

**非数项：**

- 将字符串中的每个字符看作是**ASCII码**

  `ord(字符)`

- 将整数累加

- 对散列表大小进行求余

- 对所有的**变位词**都具有相同的散列值，所以可以在字符串所在的位置加上权重因子，乘以ord值

```python
def hash_feishu(astring, tablesize):
    sum = 0
    for pos in range(len(astring)):
        sum = sum + ord(astring[pos])
    return sum%tablesize
```

## 解决冲突

- 为冲突的数据项再找一个空槽——**开放地址 open addressing**
- 避免聚集添加，还可以进行跳步
- 将容纳单个的槽变成可以容纳**数据项的集合**，所以在查找数据项的时候也需要查找槽中的集合

## 查找

重新寻找空槽的过程——**再散列 rehashing**

`newhashvalue = rehash(oldhashvalue)`

对于**线性探测**而言：`rehash(pos) = (pos+1)%sizeoftable`

“+3”**跳跃线性探测：**`rehash(pos) = (pos+3)%sizeoftable`

**跳跃式探测**的再散列通式：`rehash(pos) = (post+skip)%sizeoftable`

==skip不能被散列表大小整除，避免产生周期==

技巧：将散列表设置成**素数**

# 抽象数据类型：映射ADT Map

## 字典

可以保存**key：data**键值对的数据类型，这种键值对的关联方式称为——**映射Map**

无序集合，但是**key**唯一，所以可以唯一确定一个数据项

```
Map() 创建一个空映射，返回空的映射对象
put(key, val)  将key-val映射添加到映射中，如果key已经存在，将val替换旧值
get(key)   给定key，返回关联的数据值，如果不存在，则返回None
del  通过del map[key]的语句删除key-val的关联
len()   返回关联映射的数目
in  通过key in map 的语句形式，返回key是否存在关联中，bool类型
```

使用**HashTable类**实现ADT Map：**slot列表**用于保存key，**data列表**用于保存数据

- 保存**key列表**作为**散列表**来处理，这样可以迅速指定到key
- 散列表应该选择为素数

```python
# 使用普通列表实现
class HashTables:
    def __init__(self):
        self.slot = []
        self.data = []

    def put(self, key, value):
        if len(self.slot) == 0 or key not in self.slot:
            self.slot.append(key)
            self.data.append(value)
        else:
            # 此处查找可以另外写一个函数，使用别的查找方法
            for index in range(len(self.slot)):
                if self.slot[index] == key:
                    self.data[index] = value

    def get(self, key):
        if key in self.slot:
            # 此处的查找可以另外写一个函数，使用别的查找方法
            for index in range(len(self.slot)):
                if self.slot[index] == key:
                    return self.data[index]
        else:
            return None

    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key, value):
        self.put(key, value)


c = HashTables()
c.put(80, 12)
c.put(60, 33)
print(c.get(60))


# 使用散列表实现
class HashTable2:
    def __init__(self):
        self.size = 11
        self.slots = [None] * self.size
        self.data = [None] * self.size

    def hashfunction(self, key):
        # 获取一个散列值
        return key % self.size

    def rehash(self, oldhash):
        # 冲突解决使用线性探测“+1”再散列函数
        return (oldhash+1) % self.size

    def put(self, key, data):
        hashvalue = self.hashfunction(key)
        if self.slots[hashvalue] == None:
            self.slots[hashvalue] = key
            self.data[hashvalue] = data
        else:
            if self.slots[hashvalue] == key:
                self.data[hashvalue] = data
            else:
                nextslot = self.rehash(hashvalue)
                while self.slots[nextslot] != None and self.slots[nextslot] != key:
                    nextslot = self.rehash(nextslot)
                if self.slots[nextslot] == None:
                    self.slots[nextslot] = key
                    self.data[nextslot] = data
                else:
                    self.data[nextslot] = data

    def get(self, key):
        # 标记散列值为查找起点
        startslot = self.hashfunction(key)
        data = None
        stop = False
        found = False
        position = startslot
        # 查找key，直至空槽或回到起点
        while not found and self.slots[position] != None and not stop:
            if self.slots[position] == key:
                found = True
                data = self.data[position]
            else:
                # 没有找到key，再散列继续寻找
                position = self.rehash(position)
                # 回到起点，停止寻找
                if position == startslot:
                    stop = True
        return data

    # 通过特殊方法实现[]访问
    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key, data):
        self.put(key, data)


dirs = HashTable2()
dirs.put(80, 10)
dirs.put(70, 12)
print(dirs[70])
```







