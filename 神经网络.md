# 搭建神经网络

## 底层函数的实现

### 常用函数

张量（tensor）：
	0阶表示标量
	1阶表示向量，也就是一维数组
	2阶表示矩阵，也可以是一个二维数组

```python
tf.constant(张量内容， dtype=数据类型)   dytpe=tf.int64
# 将numpy的数据类型转换成tensor数据类型
tf.convert_to_tensor(数据名，dtype=数据类型)
```

**随机生成初始化矩阵参数，并符合正态分布**

```python
tf.random.normal(维度，mean=均值，stddev=标准差)
```

**随机生成截断式正态分布的随机数**

```python
tf.random.truncated_normal(维度，mean=均值，stddev=标准差)
# 此时生成的随机数在（μ−2σ，μ+2σ），其中μ为均差，另一个为标准差
```

**随机生成均匀分布的随机数**

```python
tf.random.uniform(维度，minval=最小值，maxval=最大值)
```

**将tensor数据类型转换成其他数据类型**

```python
tf.cast(张量名，dytpe=数据类型)
```

**选取某一个维度上张量的最大值、最小值、均值或者是一个维度的数据的求和**

```python
tf.reduce_max(张量，axis=0)  # 找出第一个维度的最大值，一般而言第一个维度就是行
tf.reduce_min(张量，axis=1)  # 找出第二个维度的最小值，一般而言第二个维度就是列
tf.reduce_mean(张量)   # 求均值，不指定维度时，所有的元素都进行操作
tf.reduce_sum(张量)  # 求和
```

**将变量标记为可训练**

```python
tf.Variable(初始值)
# 被标记的变量会在反向传播中记录梯度的信息，一般标记的都是待训练的参数
# 可更新参数w，也就是权重参数
tf.Variable(tf.random.truncted_normal([2,2], mean=0, stddev=1))
```

搭建一层神经网络，此时的待训练参数为权重**w1**，和偏置项**b1**

```python
w1 = tf.Variable(tf.random.truncted_normal([4,3],stddev=0.1))
b1 = tf.Variable(tf.random.truncted_normal([3],stddev=0.1))
# 因为后面涉及到矩阵的运算，所以b1的行维度必须和w1的列维度相同
# 此时的输入特征为4个，输出的结果有3种，所以权重的维度是[4,3]
```



**计算函数**

```python
tf.add, tf.subtract, tf.multiply, tf.divide
# 加、减、乘、除
tf.square, tf.pow, tf.sqrt, tf.matmul
# 平方、次方、开方、乘
```

**将输入的特征和标签进行配对**

```python
tf.data.Dataset.from_tensor_slices(输入特征，标签)
```

**某个函数对指定参数的求导运算**

```python
tf.GradientTape
# 一般是这样用的
with tf.GradientTape() as tape:
    若干计算过程
grad = tape.gradient(函数，对谁求导)


# 实际例子
with tf.GradientTape() as tape:
    y = tf.matmul(x_train, w1) + b1  # 神经网络乘加运算
    y = tf.nn.softmax(y)  # 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss），此时得到的结果就是分类到该标签的概率
    y_ = tf.one_hot(y_train, depth=3)  # 将标签值转换为独热码格式，方便计算loss和accuracy
    loss = tf.reduce_mean(tf.square(y_ - y))  # 采用均方误差损失函数mse = mean(sum(y-out)^2)
    loss_all += loss.numpy()  # 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确
grad = tape.gradient(loss, [w1,b1])

'''实现参数的自更新，也就是权重参数w1，偏置项b1'''
# 实现梯度更新 w1 = w1 - lr * w1_grad    b = b - lr * b_grad
w1.assign_sub(lr * grads[0])  # 参数w1自更新
b1.assign_sub(lr * grads[1])  # 参数b1自更新
```

**循环过程**

```python
for epoch in range(epoch):  # 数据集级别的循环，每个epoch循环一次数据集
    for step, (x_train, y_train) in enumerate(train_db):  # batch级别的循环 ，每个step循环一个batch
```

**返回0-1之间的一个随机数**

```python
tf.numpy.RandomState.rand(维度)  # 如果维度为空，则返回标量
```

**将两个数组进行叠加**

```python
numpy.vstack(数组1，数组2)   # 此时是按照垂直方向进行叠加的
```

**生成网络坐标点**

```python
np.mgrid[起始值：结束值：步长，…]  # 返回若干组维度相同的等差数组，[起始值，结束值)
                                       
x.ravel()  # 将x变成一维数组，相当于把x拉直了
这个的意思是将其他维度的依次排在第一组数组后面变成一个一维数组

np.c_[数组1，数组2，…]  # 将数组配对后输出，将拉伸后的一维数组进行配对

# 对于mgrid[]：
x,y=np.mgrid[2:4:0.5,1:3:1]
print(x)
print(y)
# 其结果为：
[[2.  2. ]
 [2.5 2.5]
 [3.  3. ]
 [3.5 3.5]]
[[1. 2.]
 [1. 2.]
 [1. 2.]
 [1. 2.]]
x,y=np.mgrid[1:3:1,2:4:0.5]
print(x)
print(y)
# 其结果为：
[[1. 1. 1. 1.]
 [2. 2. 2. 2.]]
[[2.  2.5 3.  3.5]
 [2.  2.5 3.  3.5]]
'''
所以对于magrid[]而言，第一个维度表示行值，第二个可以表示列值
4-2之间按照步长0.5来算有4个结果，所以是4行，3-1之间按照步长为1来算有2个结果，所以是两列
'''
```



### 测试部分

```python
# total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0
total_correct, total_number = 0, 0
for x_test, y_test in test_db:
    # 使用更新后的参数进行预测
    y = tf.matmul(x_test, w1) + b1
    y = tf.nn.softmax(y)
    pred = tf.argmax(y, axis=1)  # 返回y中最大值的索引，即预测的分类
    # 将pred转换为y_test的数据类型，调整数据类型与标签一致
    pred = tf.cast(pred, dtype=y_test.dtype)
    # 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型
    correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)
    # tf.equal(pred, y_test) 判断预测值和标签值是否相等
    # 将每个batch的correct数加起来
    correct = tf.reduce_sum(correct)
    # 将所有batch中的correct数加起来
    total_correct += int(correct)
    # total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数
    total_number += x_test.shape[0]
# 总的准确率等于total_correct/total_number，所有对了的数量/测试集中数据的总数
acc = total_correct / total_number
test_acc.append(acc)
print("Test_acc:", acc)
# acc就是accuracy，精度/准确率
```

## 激活、损失函数，正则化，优化器实现

### 激活函数

激活函数主要是这几种：**Sigmodi函数**，**Tanh函数**，**Relu函数**，**Leaky Relu函数**

首先尝试**ReLU**,速度快,但要注意训练的状态.
如果ReLU效果欠佳,尝试**Leaky ReLU**或**Maxout**等变种。
尝试**tanh**正切函数(以零点为中心,零点处梯度为1)
**sigmoid/tanh**在RNN（LSTM、注意力机制等）结构中有所应用，作为门控或者概率值.
在浅层神经网络中，如不超过4层的，可选择使用多种激励函数，没有太大的影响

著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。
原文: https://www.cnblogs.com/makefile/p/activation-function.html © 康行天下

损失函数都具有**单调性、可微性、非线性、近似恒等性**，其输出为**有限值**时，基于梯度的优化方法更加的稳定，输出为**无限值**时，可以调小学习率来得出结果

#### Sigmodi函数

![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAAjCAIAAACciZYMAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAVFSURBVHheY1SQl2MYBcMXMEHpUTBMwYiMYHbD3Lnbt7TbQLnDGoy4COZzq1+1fXqCvsj7J6ehQsMajLAI9uue6/+wxnPeFQaGf79/QgWHNRhhEbypNDR7wa0REbNQMNrIGuZgNIKHORiN4GEORiN4mIMRGcHsrEBviyqOiH7wSBuqjJ22J06Tg5ePg5mB4dfXD99eHqoKbRrOHWIqRDCfRW5fueOrmUFVO6AiqEAxc2avzbvljQ2rR1T/ZJAAEopoPrfyRVsOnzpz+uzJZeWKUEG5tNnrK2RWx+OKXSC4Pz09svGJ58zV7Y7sUKFRQDdAdATLFc1u9mbclWRrPfHcpw+P70MFuxO4d+SV7/wE5uIEP29NzWy6odM4IWI0iukMiIxgvuAyd5WPp5dOuv3z55JU16xlYFGPAneZi5u6H4E5BMDP/b37nxsFFWtA+aOAPoCYCHbo3r63ykKIQciu9czpbYhJGB8vff6bZ1ZAeSAgmzF3z6kzB+YliwObqo4t64+fWdeoB5VjeLn1yhNFfW+g1CigHyAmgg+UehbueclwZ7mPsYmpV+URqLCGvgz/69c3oTwgEEwv0zsQ2Xnij759iFr29GzmiQ4mQfWXoLIMDDeff/gro+II5SGATefW02eBVTsWtLlzRPRlaAiIa0WLF63c6vKo1Kt0P1QABGzat02Q2m4dPxmtbRw57Wi21qeby9KTZ6EV3jbtmydKbDZOnAXlkw6AsQ5lDRoATPRQ1qAEREUwe9q8w3E/JthAq14owBXBcmWr1zk8QEsNYEB5BI8CUgFRjSw3LTnmx3f2Qnkw8ObLDwYhGfTkK5tRbyPyVVTOCEtdqyMh8eMHZoN7tIimISAmgm1sVPlfPjj1EsqFgRsXn3wUFVWH8sCAz72r0+xk9uxr3xVNotUc22fW6UNlQEBdlI/h5bPzUB4CHCn3NgUWdNiQbzmsxh8F5AEiIljcTEH8+6NLmCG9ZdvFj+rmMdCurV79pjPbs3/Nypz1eO2hi1+Vwmamf1nReREiCQLi3jryD86vRmqVjQLaA8J1MKgCTmZb7hfTj56FQQMdK1eYnImIIqIrzO7YtaaRd6lr5gqqjFeyG2VPb3d/3ew3msXxA0I5mF210FHrx7kt0zBjFwge9ZUu+OoxqdOdDyqAA7ADe011GlfqC6gSu3zu9ct2TE/QFya8bi5jPnLHnWKgl7/s4OlDc5PE2R1qVx04u6EeuQYanABvBLNnLz662J1x/8R2nBHzaFZqYMeT0IXr2jygIhhAMXPm8nqZ7emhlfupEb3+PbP9H9d7zL3MwPCXRuvmgK199ObeVlAy0TD9vjx2yRNNl/a+yN99Uw/de4xUAw1SMGSnC9PmnU1jmG2SNAPKxw6AOdjvRSFicAYLABb2PTWBRvICbH8/3d5QF9VGoMxXrVm7TH2fTexU2iQuagOiuknDF7A7tq+eGsx/qsbT2LrqyE9VdS2oBBZg0z6p3CJpapXU28dK+qFiIekJsCm1wQyGYQQjF7Cpugzirv1wLnp9rFeS68R4qC6u/56oS3qYDv/zJ9egMliAkpCpf53JibqsKWdf6ues9Py/DzKlNrjBiC6iNWpXL/VXADL+/vj07uW1Hd3VE04QmPgccmBEF9EiXBwM1xZYmZia2Th7BOcOv9gFgqEaweyszJSvm3vz7QeDsKIDsI/HLmqfN3vDjFhBqMzwAUMwguMm79uzd18csDkk4dJ1YN+eFXVmUBlSwY2uqRs+GzTvO312/+pinUudZYvfQ2WGDxiydfAoIA6M8G7ScAcMDABpZhwebZxbAQAAAABJRU5ErkJggg==)

```python
tf.nn.sigmoid(x)
```

对输入进行了归一化，如果输入很小的负数，就趋近于0，输入很大的正数，就趋近于1

**缺点：**易造成梯度消失，收敛易慢，训练时间长

#### Tanh函数

![img](data:image/png;base64,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)

```python
tf.math.tanh(x)
```

输出是0，均值，但是易梯度消失，收敛慢

#### Relu函数

![img](data:image/png;base64,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)

```python
tf.nn.relu(x)
```

解决了梯度消失的问题，只需要判断**输入是否>0**
使用此函数，需要避免输入过多的负数特征

#### Leaky Relu函数

![img](data:image/png;base64,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)

```python
tf.nn.leaky_relu(x)
```

理论上很完美，但是实际不行

首选**relu函数**为激活函数，学习率设置为**较小值**，输入特征标准化（以0为均值，1为标准差的正态分布）
初始参数中心化（0为均值，根号下（2/当前层输入特征个数）为标准差的正态分布）

### 损失函数

就是预测值与标准答案的差距

主要的**loss函数**有：mes（Mean Squared Error，均方误差），自定义，ce（Cross Entropy，交叉熵）

#### mes

```python
loss_mse=tf.reduce_mean(tf.square(y_-y))
```

#### 自定义损失函数

根据实际情况自行确定函数类型，比如可以是分段函数，表示预测过度和过少所造成的不同的影响

#### 交叉熵

可以表示两个概率之间的分布距离，交叉熵越大，两个概率分布越远

H(y_,y)=![img](data:image/png;base64,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)

这里所有的参数都是概率分布，分别是标准答案的概率分布、预测结果的概率分布

```python
tf.losses.categorical_crossentropy(y_,y)
```

#### softmax和交叉熵的结合

输出先过**softmax函数**，再过**交叉熵**

```python
tf.nn.softmax_cross_entropy_with_logits(y_, y)
# 这是结合在一起的写法，也可以是分开的，也就是softmax和交叉熵都运算一遍：
y_pro=tf.nn.softmax(y)
loss_ce1=tf.losses.categorical_crossentropy(y_,y_pro)
# 运算结果都是一样的
```

### 正则化

因为存在**欠拟合**和**过拟合**，所以就需要**正则化**

在损失函数之中引入模型复杂度指标，给**w**加权重，弱化了训练参数的噪声

```python
loss = loss(y_,y) + REGULARIZER * loss(w)
# REGULARIZER：权重
```

![img](data:image/png;base64,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)

![img](data:image/png;base64,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)

第一个**正则化**公式L1：大概率会使参数变为0，可以通过稀疏矩阵来降低模型复杂度
第二个**正则化公式L2**：使参数接近0，但是不等于0

在正则化中，REGULARIZER*loss（w）不增加偏置项b，是因为这里主要是**调节function的平滑程度**，而不需要调节function的位置

L2正则化代码：

```python
#采用均方误差损失函数mse=mean(sum(y-out)^2)
loss_mse=tf.reduce_mean(tf.square(y_train-y))
#添加l2正则化
loss_regularization=[]
#tf.nn.l2_loss(w)=sum(w**2)/2
loss_regularization.append(tf.nn.l2_loss(w1))
loss_regularization.append(tf.nn.l2_loss(w2))
#求和
#例：x=tf.constant(([1,1,1],[1,1,1]))
#tf.reduce_sum(x)
#>>>6
#loss_regularization=tf.reduce_sum(tf.stack(loss_regularization))
loss_regularization=tf.reduce_sum(loss_regularization)
loss=loss_mse+0.03*loss_regularization#REGULARIZER=0.03

'''
建立一个空的列表来存放正则化后的参数w，追加到这个列表之中，reduce_mean()将列表中的元素相加
'''
```

### 建立一个两层的神经网络

```python
'''
建立一个两层的神经网络
'''
w1=tf.Variable(tf.random.normal([2,11]),dtype=tf.float32)
b1=tf.Variable(tf.constant(0.01,shape=[11]))

w2=tf.Variable(tf.random.normal([11,1]),dtype=tf.float32)
b2=tf.Variable(tf.constant(0.01,shape=[1]))
'''
for 循环中嵌套的是反向传播，求取的是梯度，epoch是对数据集的循环计数，step是batch的循环计数
在with结构中完成前向传播，计算出y，这里用到激活函数、损失函数
'''
for epoch in range(epoch):
	for step, (x_train,y_train) in enumerate(train_db):
		with tf.GradientTape() as tape:#记录梯度信息
            h1=tf.matmul(x_train,w1)+b1#记录神经网络乘加运算
            h1=tf.nn.relu(h1)
            y=tf.matmul(h1,w2)+b2

        #采用均方误差损失函数mse=mean(sum(y-out)^2)
        loss=tf.reduce_mean(tf.square(y_train-y))

        #计算loss对各个参数的梯度
        variables=[w1,b1,w2,b2]
        grads=tape.gradient(loss,variables)

        #实现梯度更新
        #w1=w1-lr*w1_gradtape.gradient是自动求导结果与[w1,b1,w2,b2]索引为0，1，2，3
        w1.assign_sub(lr*grads[0])
        b1.assign_sub(lr*grads[1])
        w2.assign_sub(lr*grads[2])
        b2.assign_sub(lr*grads[3])
生成网格坐标点：
#xx在-3到3之间以步长为0.01，yy在-3到3之间以步长0.01,生成间隔数值点，网格密度是0.1
xx,yy=np.mgrid[-3:3:.1,-3:3:.1]
#将xx,yy拉直，并合并配对为二维张量，生成二维坐标点
grid=np.c_[xx.ravel(),yy.ravel()]
grid=tf.cast(grid,tf.float32)
将每个网格坐标点送入神经网络，得到每个点的预测结果y
#将网格坐标点喂入神经网络，进行预测，probs为输出
probs=[]
for x_predict in grid:
	#使用训练好的参数进行预测
    h1=tf.matmul([x_predict],w1)+b1
    h1=tf.nn.relu(h1)
    y=tf.matmul(h1,w2)+b2#y为预测结果
    probs.append(y)
```

### 优化器

神经网络参数：
	待优化参数w，损失函数loss，学习率lr，每一次迭代一个batch，t表示当前batch的迭代的总次数

**更新参数步骤**：
	计算t时刻当前参数的梯度，让loss函数对当前的每一个参数w进行了求导
	计算t时刻的**一阶动量m**和**二阶动量v**：
		m：与梯度相关的函数
		v：与梯度平方相关的函数
	计算t时刻的下降速度
		![img](data:image/png;base64,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)

​	计算t+1时刻的下降速度
​		![img](data:image/png;base64,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)

**不同的优化器只是定义了不同的一阶动量和二阶动量**

#### SGD

随机梯度下降法

当不含动量时，一阶动量为梯度，二阶动量==1
可以使用**时间模块**来计量计算时间：

```python
now_time = time.time()
total_time = time.time() - now_time
```

#### SGDM

增加一阶动量

![img](data:image/png;base64,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)

表示**各时刻梯度方向的指数滑动平均值**，**m(t-1)**表示上一时刻的一阶动量，**β**仍然是一个超参数，经验值为**0.9**，**g**表示当前时刻的梯度
二阶动量==1

![img](data:image/png;base64,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)

![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJUAAAAXCAIAAACNuJrLAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPlSURBVGhDY1SQl2MYBUMWMEHpUTA0wWj8DW0wGn9DG4zG39AGo/E3tMFo/A1tMBp/QxuMxt/QBgTiz6xl09kzp8+eWV2rARVh8O3ff+bQjEgIJ2LGEaDs6VOLs4UgAlQApq2bQGaeXVuNsHPCnrNHpkVBOJHTjoKcdGJJLlXslI2buunoydPHN9TbMDDIBbUv33P07Jmje2elDYlxDQLxd6omZuqF7wwMHDwiUBENAxk+Bk5OXghvRX7TwTcMf++cXfMOIkAFcLo6ZurFH8h2qhvI8jNwcPBBeMsLmw6+Btm5igp2Gla32F0rjlx1m01G3iZt9iTXm/XeTm0nvgsY+aSbQdUMZkCw/Px07OFLBgZmJlYIVy/SWAFICcuZQvg/hbl43h1dNAGoBgPYtG8DZRR8aGEaVC0K+HT8PtA8JridEabyQEpEFhqgEDsX92Ozk1RwvjU+ZeptORFehh9K9uan8zIX3Pr58+rL9wwMjCxsUDWDGRCu/268/MzAICqmCmKz+yZasV679pqBiZkdLCme4ab1cFvXDjAHHRyp9DIxNcaL4mdB1aKCm68/Ae0UVQex2X2TrFiuXXsDD1DxNHetR9s6d4I5KMCmfTNa+sBA8zKgapGBuKWCBAPrk11Vsx6B+arCggx/X9w+AuYMbkBE++X26zdQlmxelOGzjauf/WMQl9AC8tkdi3yED0/DmvkoAzdfv4ay5LJjDJ9uWv3sL4ME1M5ioJ0zsGa+I5W+aOkDAyXNgKpFBo7Ksgx/r+yDmQkurp88GArRR0z8ff31G5gZFG3Ek+u82Hb3zdpy/xWwQGVlZ3doKtS83t+C059kl58gO/9A7Eyp92LdM2HG5vvA+GQC2unYUKxxvbeZqmFrpi3DwXD/2lYol8FaUYbh0+OLN6DcQQ2IiL9Tj98CSWaz6lDxY/2tF4HV04/vwAowraFI+0Zfzf6fEFVYAPnlJ8OpR6A8z2ReESZ6vK/5EtDO7z8YhOVTmgq1r/fX4bGTDCBuqyzJ8PrROViOdlSXZv57//IWKHdwAyLij+HZx48MIvZhKpf6msDp/tEHED9K+2pv7QGqhiQSeP7xE4Mo0M6L0Pz9BOwGoJ14UwxZwFlFhuHv05v7oVwNGyURhsf3j0K5gxwQE38vP39lYH5zsBsWW6efABvurw71N1A7JJHAyy9gO3thsXX6CbAQeHmot4HqKcZGX44TubazUZBl+PjkwpAoPYGt5NH5d1Tg0L292/7ZdLPkeVCBwQ2IyX8jCYgbyYkCc+MQKT1H4w8d+GgqgkrPm1DuoAej8YcCwG3PR9d2QbmDH4zWf0MZMDAAAKbBv15HN/oAAAAAAElFTkSuQmCC)

g：可以使用**with结构**直接算出损失函数对各个参数的偏导数，0时刻的一阶动量为0

```python
m_w, m_b = 0, 0
beta = 0.9
m_w = beta * m_w + (1-beta) * grads[0]
m_b = beta * m_b + (1-beta) * grads[1]
w1.assign_sub(lr * m_w)
b1.assign_sub(lr * m_b)
```

#### Adagrad

在**SGD**的基础上增加了二阶动量
m = g， 一阶动量 == 梯度
二阶动量：从开始到现在，梯度平方的累计和
![img](data:image/png;base64,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)

自适应的学习率
![img](data:image/png;base64,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)

```python
v_w = 0，v_b = 0
v_w += tf.square(grads[0])
v_b += tf.square(grads[1])
w1.assign_sub(lr * grads[0] / tf.sqrt(v_w))
b1.assign_sub(lr * grads[1] / tf.sqrt(v_b))
```

#### RMSProp

在**SGD**的基础上增加了二阶动量

m = g

![img](data:image/png;base64,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)

![img](data:image/png;base64,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)

```python
v_w , v_b = 0 , 0
beta = 0.9
v_w = v_w * beta + (1-beta) * tf.square(grads[0])
v_b = v_b * beta + (1-beta) * tf.square(grads[1])
w1.assign_sub(lr * grads[0] / tf.sqrt(v_w))
b1.assign_sub(lr * grads[1] / tf.sqrt(v_b))
```

#### Adam

同时结合SGDM的一阶动量和RMSProp的二阶动量

![img](data:image/png;base64,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)

修正一阶动量的偏差：

![img](data:image/png;base64,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)

二阶动量：

![img](data:image/png;base64,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)

修正二阶动量的偏差：

![img](data:image/png;base64,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)

![img](data:image/png;base64,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)

带入参数更新公式的是修正后的一阶动量和二阶动量

```python
m_w , m_b = 0 , 0
v_w , v_b = 0 , 0
beta1 , beta2 = 0.9 , 0.999
detal_w , detal_b = 0 , 0
global_step = 0
# 这个在一开始需要找个代码：global_step += 1
m_w = beta1 * m_w + (1-beta1) * grads[0]
m_b = beta1 * m_b + (1-beta1) * grads[1]
v_w = beta2 * v_w + (1-beta2) * tf.square(grads[0])
v_b = beta2 * v_b + (1-beta2) * tf.square(grads[1])

m_w_correction = m_w / (1 - tf.pow(beta1 , int(global_step)))
m_b_correction = m_b / (1 - tf.pow(beta1 , int(global_step)))
v_w_correction = v_w / (1 - tf.pow(beta2 , int(global_step)))
v_b_correction = v_b / (1 - tf.pow(beta2 , int(global_step)))

w1.assign_sub(lr * m_w_correction / tf.sqrt(v_w_correction))
b1.assign_sub(lr * m_b_correction / tf.sqrt(v_b_correction))
```

**Adam**的神经参数优化器是**最好的**

## Keras

tensorflow的API：tf.keras搭建神经网络，主要是六步法
**import**
**train，test**
**model = tf.keras.models.Sequential：**实现前向传播
**model.complie：**选择参数优化器，损失函数，评测指标
**model.fit：**执行训练过程，需要训练集和测试集的输入特征、标签，batch，迭代数据集次数
**model.summary：**打印网络的结构和参数统计

### Sequential（）

```python
model = tf.keras.models.Sequential([网络结构1,网络结构2,……])   # 描述各层网络
```

	网络结构：
		拉直层：tf.keras.layers.Flatten()
		全连接层：tf.keras.layers.Dense(神经元个数，activation=“激活函数”，kernel_regularizer=哪种正则化)
		"激活函数"可选：relu，softmax，sigmoid，tanh
		正则化可选：tf.keras.regularizer.l1()、tf.keras.regularizer.l2()
		卷积层：tf.keras.layers.Conv2D(fliters=卷积核个数，kernel_size=卷积核尺寸，strides=卷积步长，padding="valid"or"same")
		LSTM层（循环神经网络层）：tf.keras.layers.LSTM()
### complie（）

```python
model.complie(optimizer=参数优化器，loss=损失函数，metrics=["准确率"])
```

**优化器可选：**
	'sgd' or tf.keras.optimizers.SGD(lr=学习率，momentum=动量参数)
	'adagrad' or tf.keras.optimizers.Adagrad(lr=学习率)
	'adadelta' or tf.keras.optimizers.Adadelta(lr=学习率)
	'adam' or tf.keras.optimizers.Adam(lr=学习率，beta_1=0.9，beta_2=0.999)
**loss损失函数可选：**
	'mse' or tf.keras.losses.MeanSquaredError()
	'sqarse_categorical_crossentropy' or tf.keras.losses.SqarseCategroicalCrossentropy(from_logits=False)
		如果神经网络在输出前经过了概率分布，也就是softmax，那么from_logits就是False，表示不是原始输出
**Metrics可选：**
	'accuracy'：y_和y都是数值
	'categorical_accuracy'：y_和y都是独热码（或概率分布）
	'sqarse_categorical_accuracy'：y_是数值，y是独热码（或概率分布）

基本上都是使用数值来表示标签，以概率分布的形式来输出预测概率

### fit（）

```python
model.fit(训练集的输入特征，训练集的标签，batch_size= ,epochs= ,validation_data=(测试集的输入特征，测试集的标签),validation_split=从训练集划分多少比例
```

给测试集,validation_freq=多少次epoch测试一次)

```python
batch_size  # 表示每次喂入神经网络的样本数，也就是batch的值
epochs  3表示迭代数据集的次数
validation_split和validation_data两个选一个写就行，不需要全写
```

### summary（）

```python
model.summary()  # 这样就可以打印出来神经网络的结构和参数的统计
```

## 笔记

[tensorflow笔记]: E:\学习\机器学习\tensorflow笔记.pdf

## 代码

```python
import tensorflow as tf
from tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, Activation, Dropout, Flatten, BatchNormalization, GlobalAveragePooling2D
from tensorflow.keras import Model
import numpy as np
import os
from matplotlib import pyplot as plt


np.set_printoptions(threshold=np.inf)

# 获取数据集
cifar10 = tf.keras.datasets.cifar10
(x_train, y_train), (x_test, y_test) = cifar10.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0


# 搭建网络结构
class Baseline(Model):
    def __init__(self):
        super(Baseline, self).__init__()
        self.c1 = Conv2D(filters=6, kernel_size=(5,5), padding='same')  # 卷积层
        self.b1 = BatchNormalization()  # BN层
        self.a1 = Activation('relu')  # 激活函数（层）
        self.p1 = MaxPool2D(pool_size=(2, 2), strides=2, padding='same')  # 最大池化层
        self.d1 = Dropout(0.2)  # dropout层
        self.flatten = Flatten()  # 拉直，全连接层
        self.f1 = Dense(128, activation='relu')
        self.d2 = Dropout(0.2)
        self.f2 = Dense(10, activation='softmax')

    def __call__(self, x, **kwargs):
        x = self.c1(x)
        x = self.a1(x)
        x = self.p1(x)
        x = self.d1(x)

        x = self.flatten(x)
        x = self.f1(x)
        x = self.d2(x)
        y = self.f2(x)
        return y


# 对于卷积核过多，且都采用CBA结构的，可以新定义一个类，避免重复的代码
class ConvBNRelu(Model):
    def __init__(self, ch, kernel_size=3, strides=1, padding='same'):  # ch为深度
        super(ConvBNRelu, self).__init__()
        self.model = tf.keras.models.Sequential([
            Conv2D(ch, kernel_size, strides=strides, padding=padding),
            BatchNormalization(),
            Activation('relu')
        ])

    def __call__(self, x, **kwargs):
        x = self.model(x)
        return x


class Inception10(Model):
    def __init__(self, num_blocks, num_classes, init_ch=16, **kwargs):
        super(Inception10, self).__init__(**kwargs)
        self.in_channels = init_ch
        self.out_channels = init_ch
        self.num_blocks = num_blocks  # 表示需要有几个Inception结构块
        self.init_ch = init_ch
        self.c1 = ConvBNRelu(init_ch)
        self.blocks = tf.keras.models.Sequential()
        for block_id in range(num_blocks):
            for layer_id in range(2):
                if layer_id == 0:
                    block = InceptionBlk(self.out_channels, strides=2)
                else:
                    block = InceptionBlk(self.out_channels, strides=1)
                self.blocks.add(block)
            self.out_channels *= 2
        self.p1 = GlobalAveragePooling2D()
        self.f1 = Dense(num_classes, activation='softmax')

    def __call__(self, x, **kwargs):
        x = self.c1(x)
        x = self.blocks(x)
        x = self.p1(x)
        y = self.f1(x)
        return y


class InceptionBlk(Model):
    def __init__(self, ch, strides=1):
        super(InceptionBlk, self).__init__()
        self.ch = ch
        self.strides = strides
        self.c1 = ConvBNRelu(ch, kernel_size=1, strides=strides)
        self.c2_1 = ConvBNRelu(ch, kernel_size=1, strides=strides)
        self.c2_2 = ConvBNRelu(ch, kernel_size=3, strides=1)
        self.c3_1 = ConvBNRelu(ch, kernel_size=1, strides=strides)
        self.c3_2 = ConvBNRelu(ch, kernel_size=5, strides=1)
        self.p4_1 = MaxPool2D(3, strides=1, padding='same')
        self.c4_2 = ConvBNRelu(ch, kernel_size=1, strides=strides)

    def __call__(self, x, **kwargs):
        x1 = self.c1(x)
        x2_1 = self.c2_1(x)
        x2_2 = self.c2_2(x2_1)
        x3_1 = self.c3_1(x)
        x3_2 = self.c3_2(x3_1)
        x4_1 = self.p4_1(x)
        x4_2 = self.c4_2(x4_1)
        x = tf.concat([x1, x2_2, x3_2, x4_2], axis=3)
        return x


# model = Inception10(num_blocks=2, num_classes=10)
model = Baseline()
# 配置训练方法，选择优化器、损失函数、评测指标
model.compile(
    optimizer='adam',
    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),
    metrics=['sparse_categorical_accuracy']
)
# 断点续训
checkpoint_save_path = './checkpoint/Baseline.ckpt'
if os.path.exists(checkpoint_save_path + '.index'):
    print('----------load model----------------')
    model.load_weights(checkpoint_save_path)
cp_callback = tf.keras.callbacks.ModelCheckpoint(
    filepath=checkpoint_save_path,
    save_weights_only=True,
    save_best_only=True
)
# 执行训练过程，告知训练集和测试集
history = model.fit(x_train, y_train, batch_size=32, epochs=5,
                    validation_data=(x_test, y_test), validation_freq=1,
                    callbacks=[cp_callback])
# 打印网络结构和参数
model.summary()

# 参数提取
file = open('./weights.txt', 'w')
for v in model.trainable_variables:
    file.write(str(v.name) + '\n')
    file.write(str(v.shape) + '\n')
    file.write(str(v.numpy) + '\n')
file.close()

# acc和loss可视化
acc = history.history('sparse_categorical_accuracy')
val_acc = history.history('val_sparse_categorical_accuracy')
loss = history.history['loss']
val_loss = history.history['val_loss']

plt.subplot(1, 2, 1)
plt.plot(acc, label='T A')
plt.plot(val_acc, label='V A')
plt.title('T and V A')
plt.legend()
plt.subplot(1, 2, 2)
plt.plot(loss, label='T L')
plt.plot(val_loss, label='V L')
plt.title('T and V L')
plt.legend()
plt.show()
```











# 机器学习

https://www.kaggle.com/  很重要的网站

主要是找出**权重w**和**偏置项b**，对于**不确定是否有影响的参数**，都可以**放入模型function**之中，再给他们一个**不确定的权重**，最终再用**激活函数**来激活这个function，这样就可以得到一个优化很好的结果

使用激活函数是因为，在现实中，不是所有的模型都是线性模型，往往都是非线性的，所以需要使用激活函数

但是也要防止**过拟合**和**欠拟合**

对于loss函数，可以**regularization（正则化）**，正则化一般有两个公式，在上面搭建神经网络的的笔记中有很好的代码





在这个机器学习中，主要是因为对于很对的事实或者是影响，人类没法写出他们的数学表达式，所以希望可以计算机计算出来这个function
	所以我们提供给计算机大量的数据以及大量的结果，然后让计算机在这其中找出一定的规律，再根据我们给计算机的一个初步模型来不断地完善，最终可以很好地根据其形成的function，这个function就是最好的：**f***  预测出最佳的结果，这个就是**监督学习**
但其实，计算机根据这些数据得出的function和实际上我们无法找出的function应该是不一样的，只是一个估测的function

再到后面，就希望计算机在不知道结果的情况下，找出这个function，这个就是**无监督学习**

## Loss函数

对于**loss函数的误差**，一般而言来源于**bias、variance**，**bias就是指偏置项**，过大或者是过小都不是很好，偏置指的就是这个点离最原本的function偏离了多少，当然这个也是不可能知道的，所以也是需要计算机来进行自我的学习，**variance**是指最优的f*和这个结果之间的差异的大小，也可以说是**方差**
	**需要Low bias，Low variance**

对于比较**简单的Model**，**Error**是比较大的，但是**Model一旦过于复杂**，虽然**bias（偏置项b）**会变小，但是其**variance会变大**，使得预测**结果异常的分散**

如果是**bias过大：**
1  增加Model的复杂度
2  增加特征变量

如果是**variance过大：**
1  增加更多的数据
2  正则化，使得曲线越平滑越好

对于别人所用于测试该Model的测试集，仅仅只是看起来error比较小，但是一旦使用自己的数据集，则很有可能会出现问题，因为自己的数据集有不同于别人给好的测试集的bias，所以找出这个Model的范围就不一样了

## 学习率（learning rates）

学习率随着离期望值越来越近，我们希望学习率要越来越小，这样才会更加容易接近期望值，所以lr应该是随着epoch的进行而不断改变自己的

但是学习率也是可以有一个确定的值的，一般常用的都是0.1，0.001，0.0001等

在梯度下降算法、随机梯度下降算法（SGD）、小批量梯度下降算法等中，使用的学习率lr都是相同的，里面所有的参数都使用同一种学习率lr

但是对于不同的参数，学习率最好还是不一样，因为每个参数所占据的权重是不一样的，也就是说他们所要求的精度必然也是不同，所以此时就有一个方法：

### **Adagrad算法**

将每一个参数的每一次迭代的**梯度取方根**，用全局的学习率来除以这个数，动态地改变学习率，但是这个是在某些深度学习的模型上效果比较好，但是不是全部的深度学习模型都适用

​			取方根：梯度平方求和然后开方

![img](https://img-blog.csdn.net/20180424223550470?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Vkb2dhd2FjaGlh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### **AdaDelta算法**

不需要设置算法，与Adagrad不同的是，求得梯度的平方后，不再是相加，而是求取其历史梯度平法的平均值，也就是使用**均方根（RSM）**的方法，因为没有了全局的学习率，所以分子部分是一个全新的值：

​		 - （全局学习率 / RSM（grad））这个值然后再做均方根，最后的值就是分子

​		**RSM：**将所有值平法求和，再取其均值，然后再开方

**需要：**下降率ρ ,常数ϵ
**需要：**初始参数x1
初始化求和变量E[g^2]_0=0,E[\Delta x^2]_0=0
for t=1:T
**计算梯度：**g_t
**累加梯度：**E[g^2]_t=\rho E[g^2]_{t-1}+(1-\rho)g^2_t
**计算更新值：**\Delta x_t =-\frac{RMS[\Delta x]_{t-1}}{RMS[g]_t}g_t
**累加更新值：**E[\Delta x^2]_t=\rho E[\Delta x^2]_{t-1}+(1-\rho)\Delta x^2_t
**应用更新：**x_{t+1}=x_t +\Delta x_t
end for
**代码：**

```python
%matplotlib inline
import gluonbook as gb
from mxnet import nd
 
features, labels = gb.get_data_ch7()
 
def init_adadelta_states():
    s_w, s_b = nd.zeros((features.shape[1], 1)), nd.zeros(1)
    delta_w, delta_b = nd.zeros((features.shape[1], 1)), nd.zeros(1)
    return ((s_w, delta_w), (s_b, delta_b))
 
def adadelta(params, states, hyperparams):
    rho, eps = hyperparams['rho'], 1e-5
    for p, (s, delta) in zip(params, states):
        s[:] = rho * s + (1 - rho) * p.grad.square()
        g = ((delta + eps).sqrt() / (s + eps).sqrt()) * p.grad
        p[:] -= g
        delta[:] = rho * delta + (1 - rho) * g * g
```

这个算法可以有效地避免Adagrad算法在后期学习率速度太慢的问题

### **Adam算法**

同时结合SGDM的一阶动量和RMSProp的二阶动量

![img](data:image/png;base64,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)

此时存储的是**过去梯度的指数衰减平均值**（也就是**滑动平均值**）

修正一阶动量的偏差：

![img](data:image/png;base64,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)

二阶动量：

![img](data:image/png;base64,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)

此时存储的是**过去梯度平法的指数衰减平均值**

修正二阶动量的偏差：

![img](data:image/png;base64,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)

![img](data:image/png;base64,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)

在这一条公式中，第一个等式后面少了一个**参数ϵ**，这个值很小，仅仅只是为了防止除以0，一般是相加进去
这里的**lr**就是**全局学习率**

带入参数更新公式的是修正后的一阶动量和二阶动量，动态地调整每个参数的学习率，经过偏置校正后，每一次迭代所产生的学习率都有一个确定的范围，使得参数比较稳定	

**代码：**

```python
m_w , m_b = 0 , 0
v_w , v_b = 0 , 0
beta1 , beta2 = 0.9 , 0.999
detal_w , detal_b = 0 , 0
global_step = 0
这个在一开始需要找个代码：global_step += 1
m_w = beta1 * m_w + (1-beta1) * grads[0]
m_b = beta1 * m_b + (1-beta1) * grads[1]
v_w = beta2 * v_w + (1-beta2) * tf.square(grads[0])
v_b = beta2 * v_b + (1-beta2) * tf.square(grads[1])

m_w_correction = m_w / (1 - tf.pow(beta1 , int(global_step)))
m_b_correction = m_b / (1 - tf.pow(beta1 , int(global_step)))
v_w_correction = v_w / (1 - tf.pow(beta2 , int(global_step)))
v_b_correction = v_b / (1 - tf.pow(beta2 , int(global_step)))

w1.assign_sub(lr * m_w_correction / tf.sqrt(v_w_correction))
b1.assign_sub(lr * m_b_correction / tf.sqrt(v_b_correction))
```

**最好用的优化器就是：Adam**

## 激活函数

一个箱子中有4个蓝球，1个绿球，另一个箱子中有2个蓝球，3个绿球
选择第一个箱子的概率是P(B1)=2/3，P(B2)=1/3
那么从第一个箱子中抽出一个蓝球的概率就是：
$$
P（B1|Blue）=\frac{P(Blue|B1)P(B1)}{P(Blue|B1)P(B1)+P(Blue|B2)P(B2)}
$$
最大似然估计：
$$
f_\mu,_\Sigma(x)= \frac{1}{(2\pi)^{D/2}}\frac{1}{|\Sigma|^{1/2}}exp\{-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\}
$$

$$
\mu是一个张量，也就是均值，\Sigma是一个矩阵，协方差矩阵
主要现在是在找这两个的值
$$

$$
f_{\mu^1},_{\Sigma^1}(x) = P(Blue|B1)                
f_{\mu^2},_{\Sigma^2}(x) = P(Blue|B2) 
$$

B1箱子中属于蓝球的几率，也就是  **f **

μ和Σ的值不同，那么**Gussion distribution**的范围和位置都不一样，μ相当于就是中心点，Σ相当于是范围
有了这两个值，就可以算出**train集**样本的**概率**，也就是**f（x）**
$$
选出所有样本的几率：L(\mu,\Sigma) = f_\mu,_\Sigma(x^1)f_\mu,_\Sigma(x^2)f_\mu,_\Sigma(x^3)......f_\mu,_\Sigma(x^{79})
$$
表示总共有79个样本，每一个*f*都是找出这个点的概率，**L(μ，Σ)**的概率越大，那么**μ和Σ**就是最优的：
$$
\mu^*,\Sigma^* = arg\max\limits_{\mu,\Sigma}L(\mu,\Sigma)
$$
这个就是最有可能找出这些样本的**μ和Σ**
$$
\mu^*=\frac{1}{79}\sum_{n=1}^{79}x^n
平均就是最大的
$$

$$
\Sigma^*=\frac{1}{79}\sum_{n=1}^{79}(x^n-\mu^*)(x^n-\mu^*)^T
$$

在现实的Model之中，通常几种类别都共用一个**相同的Σ**	均值可以不同：
$$
L(\mu^1,\mu^2,\Sigma) = f_{\mu^1},_\Sigma(x^1)......f_{\mu^1},_\Sigma(x^{79})
*f_{\mu^2},_\Sigma(x^{80})......f_{\mu^2},_\Sigma(x^{140})
$$
$\mu$的算法还是一样的，$\Sigma=\frac{79}{140}\Sigma^1+\frac{61}{140}\Sigma^2$,这就是最新的**Σ**的算法
这样如果是两个因素来分类的话，他们的两个高斯分布的边界是**线性**的，而不再和之前一样是非线性的
$$
P（C_1|x）=\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)}
=\frac{1}{1+\frac{P(x|C_2)P(C_2)}{P(x|C_1)P(C_1)}}
=\frac{1}{1+\exp(-z)}
=\sigma(z)
$$ {Sigmod function}

$$
z = ln\frac{P(x|C_1)P(C_1)}{P(x|C_2)P(C_2)}
$$

$\sigma(z)=\frac{1}{1+e^{-z}}$ = **Sigmoid** function

$z = wx + b = \sum_{i}w_ix_i + b$**w**就是权重，**b**就是bias，这里的**output**就只在（0，1）之间

**Step 1:**
$$
P(C_1|x)=f_{w,b}(x)=\sigma(z)=\sigma(\sum_iw_ix_i+b)
$$
**Step 2:**
$$
Trainning	data=(x^n,{y-}^n),{y^*}^n表示的是结果，一般来说就是指0或1
$$

$$
L(f)=\frac{1}{2}\sum_n(f(x^n)-{y^*}^n)^2
$$

**Step 3:**
$$
\frac{\delta(f_{w,b}(x)-y^*)^2}{\delta w_i}=2(f(x)-y^*)\frac{\delta f(x)}{\delta z}\frac{\delta z}{\delta w}
=2(f(x)-y^*)f(x)(1-f(x))x_i
$$
f(x)是指预测的结果，$y^*$表示应该是的结果，此时有一个问题，无论离需要的目标的远近都会存在两头梯度是0的情况

对于function set有两种处理方式，第一种是对μ和Σ没有任何的假设，直接求取最优的w和b——**logistics regression**

第二种是规定了μ，也就是$\mu^1,\mu^2$，在相同的Σ下，找寻新的**w和b**：
$$
w^T=(\mu^1-\mu^2)^T\Sigma^{-1}
$$

$$
b = -\frac{1}{2}(\mu^1)^T(\Sigma^1)^{-1}\mu^1+\frac{1}{2}(\mu^2)^T(\Sigma^2)^{-1}\mu^2+ln\frac{N_1}{N_2}
$$

这两种办法找出的**w和b**都不一样

第一种使用的是**logistic regression**——**discriminative model**
第二种出现的模型就是——**generative model**	
		使用于小批量的训练数据集**（less training data）**，受数据的影响是比较小的
		label本身具有问题，假设也不符合实际，导致数据产生了过多的噪声**（more robust to the noise）**

## Backpropagation（反向传播）

首先需要网络的参数 $\theta={w_1,w_2,...,b_1,b_2}$，然后选择一个初始的参数，计算这些参数对**Loss function**的梯度，也就是计算每一个**w，b**的偏微分

然后**更新参数：**$\theta^1=\theta^0-\eta \bigtriangledown L(\theta^0)$
$$
\bigtriangledown L(\theta^0) =
\begin{bmatrix} \frac{\delta L(\theta)}{\delta w_1} \\ \frac{\delta L(\theta)}{\delta w_2} \\ ...\\ \frac{\delta L(\theta)}{\delta b_1} \\ ...\end{bmatrix}
$$
经过持续地更新参数	通常来说有**Loss 函数**有许多维度，比如在云端，可能有很多层神经网络，一层神经网络就有几千个参数，那么**Loss 函数**就是几百万维的矩阵——所以需要**反向传播**——比较有效率地执行梯度下降算法

Training data：$x^n$         神经网络待训练参数集：$\theta$          输出：$y^n$                最优输出（正确答案）：$\widehat{y}^n$                输出和最优输出之间距离的function：$C^n$

$L(\theta)=\sum^N_{n=1}C^n(\theta)$  如果**C**过大，代表输出和最优输出之间的距离过大，也就是这个输出不是很好





## 监督学习

**Loss**：不是损失函数，而是指模型的**预测失败**的概率，然后计算机会自动找出最低的**Loss**

需要给计算机**正确的、明确的标签**，这样计算机在应对相同或者是类似场景的时候才能预测成功

## 强化学习

使用**reward**引导机器学习的方向，使其能在不断的尝试之中找出最优解

## 无监督学习

只给计算机**数据**，但是不提供标注

## Domain Adversarial Learning（transfer learning）

在训练集和测试集的结构不同的情况下可以进行学习

## Meta Learning

**编写一个程序使得该程序具备可以编写一个能让机器学习的程序的能力**
program designing program for learning

也就是赋予机器**如何学习的能力**，因为现如今的机器都只是**勤奋**但是不是**天资聪颖**的，机器使用的是**人类创造**的算法，所以可能不是很适应于机器，所以才会有效率低下的问题

## Life-long Learning

终身学习，让机器给布置各个阶段的任务，最终进化为**天网**级别的机器，这个目前无法实现，具备了很多的难点

# 卷积神经网络

减少带训练参数（特征参数），进行特征提取工作——利用卷积核

输入特征是**单通道**的灰度图，可以使用**深度为1**的卷积核（1*1）
输入特征是**三通道的*彩色图，可以使用**3*3**或**5* 5 *3**的卷积核

==卷积核通道数 = 输入特征图的通道数==
==输入特征图的深度 = 当前卷积核的深度==
==当前层卷积核的数目 = 输出特征图的深度==

5* 5 *3表示的是**5行5列3深**，是一个三维的

单通道5* 5的图，卷积核为3* 3，卷积核提取步长为1，偏置项b为1——输出像素值 = 对应数据相乘求和 + b

**当输入特征图被卷积核遍历完成的时候，就会得到一张输出特征图，当有n个卷积核时，就会得到n个输出特征图**
但是输出特征图也有可能是下一层的输入特征图

==卷积层网络主要模块：==
	卷积层——BN层——激活层——池化层——dropout层——从输入特征图中提取的输出特征图数据送入**全连接**网络——识别预测=

==Conv2D（）的参数==
**filters:** 整数，输出空间的维度 （即卷积中滤波器的输出数量）。=

**kernel_size:** 一个整数，或者单个整数表示的元组或列表， 指明 1D 卷积窗口的长度。

**strides:** 一个整数，或者单个整数表示的元组或列表， 指明卷积的步长。 指定任何 stride 值 != 1 与指定 dilation_rate 值 != 1 两者不兼容。

**padding:** "valid", "causal" 或 "same" 之一 (大小写敏感) "valid" 表示「不填充」。 "same" 表示填充输入以使输出具有与原始输入相同的长度。 "causal" 表示因果（膨胀）卷积， 例如，output[t] 不依赖于 input[t+1:]， 在模型不应违反时间顺序的时间数据建模时非常有用。 详见 WaveNet: A Generative Model for Raw Audio, section 2.1。

**data_format:** 字符串, "channels_last" (默认) 或 "channels_first" 之一。输入的各个维度顺序。 "channels_last" 对应输入尺寸为 (batch, steps, channels) (Keras 中时序数据的默认格式) 而 "channels_first" 对应输入尺寸为 (batch, channels, steps)。

**dilation_rate:** 一个整数，或者单个整数表示的元组或列表，指定用于膨胀卷积的膨胀率。 当前，指定任何 dilation_rate 值 != 1 与指定 stride 值 != 1 两者不兼容。

**activation:** 要使用的激活函数 (详见 activations)。 如未指定，则不使用激活函数 (即线性激活： a(x) = x)。

**use_bias:** 布尔值，该层是否使用偏置向量。

**kernel_initializer:** kernel 权值矩阵的初始化器 (详见 initializers)。

**bias_initializer:** 偏置向量的初始化器 (详见 initializers)。

**kernel_regularizer:** 运用到 kernel 权值矩阵的正则化函数 (详见 regularizer)。

**bias_regularizer:** 运用到偏置向量的正则化函数 (详见 regularizer)。

**activity_regularizer:** 运用到层输出（它的激活值）的正则化函数 (详见 regularizer)。

**kernel_constraint:** 运用到 kernel 权值矩阵的约束函数 (详见 constraints)。

**bias_constraint:** 运用到偏置向量的约束函数 (详见 constraints)。

https://keras.io/zh/layers/convolutional/ ==keras中文文档==

## 代码

```python
model = tf.keras.models.Sequential([
    Conv2D(filters=6, kernel_size=(5, 5), padding='same'), # 卷积层
    BatchNormalization()，   # BN层
    Activation('relu')，  # 激活层
    MaxPool2D(pool_size=(2, 2), strides=2, padding='same'),   # 池化层
    Dropout(0.2),   # Dropout层
    Flatten(),  # 拉直层
    Dense(10, activation='softmax')  # 全连接
])
```



## 卷积层

```python
tf.keras.layers.Conv2D(
	filters=卷积核个数
	kernel_size=卷积核尺寸  # 正方形的可以是：（核高h，核宽w）
	strides=滑动步长   # 默认为1
	padding='same'或'valid'   # 默认不使用全0填充
	activation='relu'或'sigmoid'或'tanh'或'softmax'，如果卷积之后还有批标准化（BN）操作，不在这进行激活，也就是没有激活函数
	input_shape=(高，宽，通道数)   # 输入特征图维度，可以省略
）


model = tf.keras.models.Sequential([
	Conv2D(6, 5, padding='valid', activation='sigmoid'), 
	MaxPool2D(2, 2),
	Conv2D(6, (5, 5), padding='valid', activation='sigmoid')
	MaxPool2D(2, (2, 2)),
	Conv2D(filters=6, kernel_size=(5, 5), padding='valid', activation='sigmoid' )
	MaxPool2D(pool_size=(2, 2), strides=2),
	Flatten(),
	Dense(10, activation='softmax')
])
# 一般使用第三种，代码的可读性好
```

## BN层

批标准化层：使一batch的数据标准化，符合均值为0，方差为1的正态分布，使偏移的特征数据回到0均值的附近
$$
H^{'k}_{i}=\frac{H^k_i-\mu^k_{batch}}{\sigma^k_{batch}}
$$
$H^{'k}_i$：BN后，第k个卷积核的输出特征图中的第i个像素点

$H^k_i$：BN前，第k个卷积核，batch张输出特征图中第i个像素点

$\mu^k_{batch}$：BN前，第k个卷积核，batch张输出特征图中所有像素点的平均值

$\sigma^k_{batch}$：BN前，第k个卷积核，batch张输出特征图中所有像素点的标准差
$$
\mu^k_{batch}=\frac{1}{m}\sum^{m}_{i=1}H^k_i
$$

$$
\sigma^k_{batch}=\sqrt{ \delta+\frac{1}{m}\sum^{m}_{i=1}(H^k_i-\mu^k_{batch})^2}
$$

可以让每个**像素点- 均值（标准差）**自更新

为每个卷积核都引入可训练因子γ（缩放因子）和β（偏移因子）
$$
x^k_i = \gamma_kH^{'k}_i+\beta_k
$$
$H^{'k}_i$：批标准化后的特征数据

$x^k_i$：经过γ和β优化后的特征数据

## 池化层

```python
'''最大池化：'''
tf.keras.layers.MaxPool2D(
	pool_size=池化核尺寸,
	strides=步长,
	padding='same'或'valid'
)
'''均值池化：'''
tf.keras.layers.AveragePooling2D(
	pool_size=池化核尺寸,
	strides=步长,
	padding='same'或'valid'
)
```

## Dropout层

缓解神经网络过拟合现象，按照一定的比例从神经网络中临时舍弃

## InceptionNet

```python
InceptionNet网络结构的TF描述：

import tensorflow as tf
from tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, Activation, Dropout, Flatten, BatchNormalization, GlobalAveragePooling2D
from tensorflow.keras import Model


# 对于卷积核过多，且都采用CBA结构的，可以新定义一个类，避免重复的代码
class ConvBNRelu(Model):
    def __init__(self, ch, kernel_size=3, strides=1, padding='same'):  # ch为深度
        super(ConvBNRelu, self).__init__()
        self.model = tf.keras.models.Sequential([
            Conv2D(ch, kernel_size, strides=strides, padding=padding),
            BatchNormalization(),
            Activation('relu')
        ])
    def __call__(self, x, **kwargs):
        x = self.model(x)
        return x

# 这个就是整个神经网络模块
class Inception10(Model):
    def __init__(self, num_blocks, num_classes, init_ch=16, **kwargs):
        super(Inception10, self).__init__(**kwargs)
        self.in_channels = init_ch
        self.out_channels = init_ch
        self.num_blocks = num_blocks
        self.init_ch = init_ch
        self.c1 = ConvBNRelu(init_ch)
        self.blocks = tf.keras.models.Sequential()
        for block_id in range(num_blocks):
            for layer_id in range(2):
                if layer_id == 0:
                    block = InceptionBlk(self.out_channels, strides=2)  # 输出的特征图尺寸减半
                else:
                    block = InceptionBlk(self.out_channels, strides=1)
                self.blocks.add(block)
            self.out_channels *= 2                                      # 因为尺寸减半了，所以需要将深度加深，尽可能保证特征抽取中信息的承载量一致
        self.p1 = GlobalAveragePooling2D()
        self.f1 = Dense(num_classes, activation='softmax')
    def __call__(self, x, **kwargs):
        x = self.c1(x)
        x = self.blocks(x)
        x = self.p1(x)
        y = self.f1(x)
        return y

# 这个类描述的是Inception结构块中的卷积结构分支，有4个，因为在整个过程中，出现了多个Inception结构块，所以这里单独成一类，避免代码重复，增加可读性
class InceptionBlk(Model):
    def __init__(self, ch, strides=1):
        super(InceptionBlk, self).__init__()
        self.ch = ch
        self.strides = strides
        self.c1 = ConvBNRelu(ch, kernel_size=1, strides=strides)

        self.c2_1 = ConvBNRelu(ch, kernel_size=1, strides=strides)
        self.c2_2 = ConvBNRelu(ch, kernel_size=3, strides=1)

        self.c3_1 = ConvBNRelu(ch, kernel_size=1, strides=strides)
        self.c3_2 = ConvBNRelu(ch, kernel_size=5, strides=1)

        self.p4_1 = MaxPool2D(3, strides=1, padding='same')
        self.c4_2 = ConvBNRelu(ch, kernel_size=1, strides=strides)
    def __call__(self, x, **kwargs):
        x1 = self.c1(x)
        x2_1 = self.c2_1(x)
        x2_2 = self.c2_2(x2_1)
        x3_1 = self.c3_1(x)
        x3_2 = self.c3_2(x3_1)
        x4_1 = self.p4_1(x)
        x4_2 = self.c4_2(x4_1)
        x = tf.concat([x1, x2_2, x3_2, x4_2], axis=3)
        return x
model = Inception10(num_blocks=2, num_classes=10)   # num_blocks指定为2，也就是block_0和block_1，num_classes指定网络是几分类的
	#  因为cifar10数据集是10分类的，所以这里的num_classes=10
```

## ResNet

层间残差跳连，引入前方特征信息，缓解梯度消失问题，使神经网络层数增加成为可能

56层的神经网络的错误率要大于20层神经网络的错误率，可能原因是随着层数的增加，导致后面的特征丢失了前面的特征的原本模样

所以可以将前面的特征直接接在后面层，使输出结果H（x）包含了堆叠卷积的非线性输出F（x），和跳过这些堆叠卷积而直接传入的恒等映射x，让它们对应元素相加

![image-20201217193236349](C:\Users\梅桂楠\AppData\Roaming\Typora\typora-user-images\image-20201217193236349.png)

对于实线部分，特征图的维度并没有发生改变，也就是特征图的高、深、宽都是一样的

虚线部分，维度不同，因为两层的卷积层中，步长发生了改变，使通道数发生了改变，也就是卷积核个数发生了改变，从而改变了特征图的深度

因为**改变了步长（strides）**，所以**输出特征图的尺寸**发生改变，所以不得不要**改变深度**，使特征抽取中的信息承载一致

因为**深度的改变**，所以**通道数也会发生改变**，特征图的**维度也发生了改变**

所以需要**借助1*1的卷积W**来**调整输入特征图x的维度**，使W（x）和F（x）的维度一致

==通过**if**语句来判断是否需要执行1* 1卷积核的操作==

```python
from tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, Activation, Dropout, Flatten, BatchNormalization, GlobalAveragePooling2D
from tensorflow.keras import Model


class ResnetBlock(Model):
    def __init__(self, filters, strides=1, residual_path=False):   # True表示用虚线连接，False表示实线连接
        super(ResnetBlock, self).__init__()
        self.filters = filters
        self.strides = strides
        self.residual_path = residual_path

        self.c1 = Conv2D(filters, (3, 3), strides=strides, padding='same', use_bias=False)
        self.b1 = BatchNormalization()
        self.a1 = Activation('relu')

        self.c2 = Conv2D(filters, (3, 3), strides=1, padding='same', use_bias=False)
        self.b2 = BatchNormalization()

        if residual_path:
            self.down_c1 = Conv2D(filters, (1, 1), strides=1, padding='same', use_bias=False)
            self.down_b1 = BatchNormalization()

        self.a2 = Activation('relu')

    def __call__(self, inputs, **kwargs):
        residual = inputs
        x = self.c1(inputs)
        x = self.b1(x)
        x = self.a1(x)

        x = self.c2(x)
        y = self.b2(x)

        if self.residual_path:
            residual = self.down_c1(inputs)
            residual = self.down_b1(residual)

        out = self.a2(y + residual)
        return out

class ResNet18(Model):
    def __init__(self, block_list, initial_filters=64):
        super(ResNet18, self).__init__()
        self.num_blocks = len(block_list)
        self.block_list = block_list
        self.out_filters = initial_filters

        self.c1= Conv2D(self.out_filters, (3, 3), strides=1, padding='same', use_bias=False,
                        kernel_initializer='he_normal')  # 不使用偏置向量，正态分布初始化器
        self.b1 = BatchNormalization()
        self.a1 = Activation('relu')

        self.blocks = tf.keras.models.Sequential()   # 这个函数是一个容器，放置的网络结构
        # 构建ResNet网络结构，总共是4个，所以根据num_block来循环
        for block_id in range(self.num_blocks):
            for layer_id in range(block_list(block_id)):
                if block_id != 0 and layer_id == 0:  # 对除第一个block以外的每一个block执行ResnetBlock类中的操作
                    block = ResnetBlock(self.out_filters, strides=2, residual_path=True)
                else:
                    block = ResnetBlock(self.out_filters, residual_path=False)
                self.blocks.add(block)  # 将构建好的block加入Resnet
            self.out_filters *= 2  # 下一个卷积核的数目是上一个的两倍，因为步长为2
        self.p1 = tf.keras.layers.GlobalAveragePooling2D()
        self.f1 = tf.keras.layers.Dense(10)

    def __call__(self, inputs, **kwargs):
        x = self.c1(inputs)
        x = self.b1(x)
        x = self.a1(x)

        x = self.blocks(x)

        x = self.p1(x)
        y = self.f1(x)
        return y


model = ResNet18([2, 2, 2, 2])

# Resnet第一层是一个3*3的卷积，然后是8个跳连，最后是一层全连接
```

# 循环神经网络

























